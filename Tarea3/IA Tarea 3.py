# -*- coding: utf-8 -*-
"""IA_Tarea_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zhlMMQgQt6IEJFAn8dQAVc-wDic3E4k0

# Tarea 3 de Inteligencia Artificial - Diego Pastrian & Ignacio Medina

En este documento se explora un enfoque dentro del campo de las redes neuronales artificiales (ANN): las ***Kolmogorov-Arnold Networks (KAN)***. El principal objetivo es implementar esta arquitectura siguiendo el tutorial presente en la p谩gina [A from scratch implementation of kolmogorov arnold networks (KAN).](https://mlwithouttears.com/2024/05/15/a-from-scratch-implementation-of-kolmogorov-arnold-networks-kan/).

## Item 1. Implementaci贸n del Tutorial.

### Implementaci贸n.
La primera actividad a realizar es la implementaci贸n del algoritmo KAN.

*   El input de la neurona ***xin*** se representa por $\mathbf{x}^{\text{in}} = [x^{\text{in}}_1, \dots, x^{\text{in}}_M]$, donde las neuronas tienen ***n_in*** inputs los cuales a trav茅s de la neurona sufrir谩n una transformaci贸n intermedia $\phi(x^{\text{in}}_i,w^i)$.

*   De lo anterior, $x^{\text{mid}}_i = \phi(x^{\text{in}}_i, \mathbf{w}^i)$ representa a la salida intermedia en la neurona (***xmid*** en c贸digo). $\mathbf{w}^i = [w^i_1, \dots, w^i_K]$ son los pesos ***weights***, estos indican la importancia de la conexi贸n entre una neurona y otra. Los pesos se inicializan con valores aleatorios entre -1 y 1.

*   El sesgo $b$, representado en el c贸digo por ***bias*** sirve para ajustar el resultado obtenido. Se inicializa en 0 y se ajusta con el entrenamiento del modelo.

*   Se tiene una salida ***xout***, que ser铆a el resultado de salida de la neurona.

*   Desde la salida de la red hacia las capas anteriores (retropropagaci贸n) se reajustan los pesos $W^i$ y el sesgo $b$ minimizando la p茅rdida $\mathcal{L}$ (Que mide la diferencia entre las predicciones del modelo y los valores reales) con el m茅todo del gradiente descendiente. Para esto:
      *  Se utiliza la regla de la cadena para descomponer las derivadas en partes manejables en una neurona individual.
      \$[
\frac{\partial \mathcal{L}}{\partial b} = \frac{\partial \mathcal{L}}{\partial x^{\text{out}}} \cdot \frac{\partial x^{\text{out}}}{\partial b}.
\$]
\$[
\frac{\partial \mathcal{L}}{\partial w^i_j} = \frac{\partial \mathcal{L}}{\partial x^{\text{out}}} \cdot \frac{\partial x^{\text{out}}}{\partial w^i_j}, \quad \forall i, j.
\$]
      *   De lo anterior, se puede calcular $\( \frac{\partial x^{\text{out}}}{\partial b} \)$ y $\( \frac{\partial x^{\text{out}}}{\partial w^i_j} \)$ con las variables internas a la neurona.
"""

import numpy as np

class Neuron:

    def __init__(self, n_in, n_weights_per_edge, weights_range=None):
        self.n_in = n_in  # n. inputs
        self.n_weights_per_edge = n_weights_per_edge
        weights_range = [-1, 1] if weights_range is None else weights_range
        self.weights = np.random.uniform(weights_range[0], weights_range[-1], size=(self.n_in, self.n_weights_per_edge))
        self.bias = 0
        self.xin = None  # input variable
        self.xmid = None  # edge variables
        self.xout = None  # output variable
        self.dxout_dxmid = None  # derivative d xout / d xmid: (n_in, )
        self.dxout_dbias = None  # derivative d xout / d bias
        self.dxmid_dw = None  # derivative d xmid / d w: (n_in, n_par_per_edge)
        self.dxmid_dxin = None  # derivative d xmid / d xin
        self.dxout_dxin = None  # (composite) derivative d xout / d xin
        self.dxout_dw = None  # (composite) derivative d xout / d w
        self.dloss_dw = np.zeros((self.n_in, self.n_weights_per_edge))  # (composite) derivative d loss / d w
        self.dloss_dbias = 0  # (composite) derivative d loss / d bias

    def __call__(self, xin):
        # forward pass: compute neuron's output
        self.xin = np.array(xin)
        self.get_xmid()
        self.get_xout()

        # compute internal derivatives
        self.get_dxout_dxmid()
        self.get_dxout_dbias()
        self.get_dxmid_dw()
        self.get_dxmid_dxin()

        assert self.dxout_dxmid.shape == (self.n_in, )
        assert self.dxmid_dxin.shape == (self.n_in, )
        assert self.dxmid_dw.shape == (self.n_in, self.n_weights_per_edge)

        # compute external derivatives
        self.get_dxout_dxin()
        self.get_dxout_dw()

        return self.xout

    def get_xmid(self):
        # compute self.xmid
        pass

    def get_xout(self):
        # compute self.xout
        pass

    def get_dxout_dxmid(self):
        # compute self.dxout_dxmid
        pass

    def get_dxout_dbias(self):
        # compute self.dxout_dbias
        pass  #self.dxout_dbias = 0  # by default

    def get_dxmid_dw(self):
        # compute self.dxmid_dw
        pass

    def get_dxmid_dxin(self):
        # compute self.dxmid_dxin
        pass

    def get_dxout_dxin(self):
        self.dxout_dxin = self.dxout_dxmid * self.dxmid_dxin

    def get_dxout_dw(self):
        self.dxout_dw = np.diag(self.dxout_dxmid) @ self.dxmid_dw

    def update_dloss_dw_dbias(self, dloss_dxout):
        self.dloss_dw += self.dxout_dw * dloss_dxout
        self.dloss_dbias += self.dxout_dbias * dloss_dxout

    def gradient_descent(self, eps):
        self.weights -= eps * self.dloss_dw
        self.bias -= eps * self.dloss_dbias

"""

La funci贸n de activaci贸n $\sigma$ puede estar dada por las funciones:


*   ***relu*** : Funci贸n ReLU
  $$
  \sigma(x) =
  \begin{cases}
  0, & \text{si } x \leq 0 \\
  x, & \text{si } x > 0
  \end{cases}
  $$
    

*   ***tanh_act***: Funci贸n Tangente hiperb贸lica $$(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}}$$
*   ***sigmoid_act***: Funci贸n sigmoide $$\sigma(x) = \frac{1}{1 + e^{-x}}$$

Estas funciones son esenciales para introducir no linealidad al modelo, permitiendo que la red neuronal pueda aprender relaciones complejas entre las entradas y salidas. Para KAN, estas aseguran que las transformaciones entre las capas sean flexibles para descomponer y aproximar funciones continuas.
"""

import math

def relu(x, get_derivative=False):
    return x * (x > 0) if not get_derivative else 1.0 * (x >= 0)

def tanh_act(x, get_derivative=False):
    if not get_derivative:
        return math.tanh(x)
    return 1 - math.tanh(x) ** 2

def sigmoid_act(x, get_derivative=False):
    if not get_derivative:
        return 1 / (1 + math.exp(-x))
    return sigmoid_act(x) * (1 - sigmoid_act(x))

"""A continuaci贸n se implementa la clase ***NeuronNN***, que corresponde a una neurona m谩s general en el contexto de redes neuronales, heredando la clase ***Neuron*** para el c谩lculo de los valores intermedios $x^{mid}$ y finales $x^{out}$ de una neurona, adem谩s el c谩lculo de las derivadas auxiliares necesarias para la retropropagaci贸n.


*   Se calcula la salida intermedia ***xmid*** como el producto elemento a elemento entre las entradas ***xin*** por sus correspondientes pesos ***weight***.
*   Se calcula ***xout*** con la funci贸n de activaci贸n evaluada en las salidas intermedias y el sesgo $b$.
$ x^{\text{out}} = \sigma\left(\mathbf{x}^{\text{mid}}, b\right) := \sigma\left(b + \sum_{i=1}^M x^{\text{mid}}_i\right)$, siendo $\sigma$ la funci贸n de activaci贸n, la cual se debe definir en la inicializaci贸n.
*   Para ajustar los par谩metros como el sesgo $b$ y los pesos $w$, se implementan funciones para el c谩lculo de las derivadas parciales de la salida $x^{out}$ con respecto a $x^{mid}$.


"""

class NeuronNN(Neuron):

    def __init__(self, n_in, weights_range=None, activation=relu):
        super().__init__(n_in, n_weights_per_edge=1, weights_range=weights_range)
        self.activation = activation
        self.activation_input = None

    def get_xmid(self):
        self.xmid = self.weights[:, 0] * self.xin

    def get_xout(self):
        self.activation_input = sum(self.xmid.flatten()) + self.bias
        self.xout = self.activation(self.activation_input, get_derivative=False)

    def get_dxout_dxmid(self):
        self.dxout_dxmid = self.activation(self.activation_input, get_derivative=True) * np.ones(self.n_in)

    def get_dxout_dbias(self):
        self.dxout_dbias = self.activation(self.activation_input, get_derivative=True)

    def get_dxmid_dw(self):
        self.dxmid_dw = np.reshape(self.xin, (-1, 1))

    def get_dxmid_dxin(self):
        self.dxmid_dxin = self.weights.flatten()

"""Lo particular de las redes Kolmogorov-Arnold es la utilizaci贸n de la funci贸n de borde $\phi$. En el segmento de c贸digo posterior se define el uso de las funciones B-spline como las funciones  en el borde, con la excepci贸n de 1(), que se define como la funci贸n sigmoide modificada.
Las B-splines son funciones que se utilizan para representar funciones continuas de manera suave.
"""

from scipy.interpolate import BSpline

def get_bsplines(x_bounds, n_fun, degree=3, **kwargs):
    grid_len = n_fun - degree + 1
    step = (x_bounds[1] - x_bounds[0]) / (grid_len - 1)
    edge_fun, edge_fun_der = {}, {}

    # SiLU bias function
    edge_fun[0] = lambda x: x / (1 + np.exp(-x))
    edge_fun_der[0] = lambda x: (1 + np.exp(-x) + x * np.exp(-x)) / np.power((1 + np.exp(-x)), 2)

    # B-splines
    t = np.linspace(x_bounds[0] - degree * step, x_bounds[1] + degree * step, grid_len + 2 * degree)
    t[degree], t[-degree - 1] = x_bounds[0], x_bounds[1]
    for ind_spline in range(n_fun - 1):
        edge_fun[ind_spline + 1] = BSpline.basis_element(t[ind_spline:ind_spline + degree + 2], extrapolate=False)
        edge_fun_der[ind_spline + 1] = edge_fun[ind_spline + 1].derivative()
    return edge_fun, edge_fun_der

"""
Se implementa la neurona ***NeuronKAN* que hereda de la clase ***Neuron***. Esta reemplaza el sesgo $b$ por el uso de las funciones borde $f_k$ ya explicadas anteriormente.

*   La salida intermedia ***xmid*** se calcula como una combianaci贸n lineal de las transformaciones univariadas $\phi(x)$, que son las funciones borde $f_k(w)$

*   La salida ***xout*** se obtiene con la aplicaci贸n de una tangente hiperb贸lica como funci贸n de activaci贸n sobre la suma de las salidas intermedias. Al utilizar $:= tanh$ como funci贸n de activaci贸n, se mantiene la variable de salida entre -1 y 1. Esto facilita el ajuste de las B-splines.

*   Para ajustar los pesos $w$, se implementan las derivadas necesarias a calcular.

"""

class NeuronKAN(Neuron):

    def __init__(self, n_in, n_weights_per_edge, x_bounds, weights_range=None, get_edge_fun=get_bsplines, **kwargs):
        self.x_bounds = x_bounds
        super().__init__(n_in, n_weights_per_edge=n_weights_per_edge, weights_range=weights_range)
        self.edge_fun, self.edge_fun_der = get_edge_fun(self.x_bounds, self.n_weights_per_edge, **kwargs)

    def get_xmid(self):
        # apply edge functions
        self.phi_x_mat = np.array([self.edge_fun[b](self.xin) for b in self.edge_fun]).T
        self.phi_x_mat[np.isnan(self.phi_x_mat)] = 0
        self.xmid = (self.weights * self.phi_x_mat).sum(axis=1)

    def get_xout(self):
        # note: node function <- tanh to avoid any update of spline grids
        self.xout = tanh_act(sum(self.xmid.flatten()), get_derivative=False)

    def get_dxout_dxmid(self):
        self.dxout_dxmid = tanh_act(sum(self.xmid.flatten()), get_derivative=True) * np.ones(self.n_in)

    def get_dxmid_dw(self):
        self.dxmid_dw = self.phi_x_mat

    def get_dxmid_dxin(self):
        phi_x_der_mat = np.array([self.edge_fun_der[b](self.xin) if self.edge_fun[b](self.xin) is not None else 0
                                  for b in self.edge_fun_der]).T  # shape (n_in, n_weights_per_edge)
        phi_x_der_mat[np.isnan(phi_x_der_mat)] = 0
        self.dxmid_dxin = (self.weights * phi_x_der_mat).sum(axis=1)

    def get_dxout_dbias(self):
        # no bias in KAN!
        self.dxout_dbias = 0

"""Una capa completamente conectada es una colecci贸n de neuronas, donde cada entrada se conecta a todas las neuronas de la capa siguiente. Cada conexi贸n tiene un peso asignado. Para esto, se utiliza la clase llamada ***FullyConnectedLayer***. Esto asegura que todas las entradas influyan en todas las salidas, creando un modelo que capture relaciones complejas en los datos.


En una capa completamente conectada, una entrada $x_i$ afecta la p茅rdida total a partir de m煤ltiples caminos, pues como se explic贸 anteriormente, $x_i$ influye en todas las salidas $y_j$ de la capa. Esto se representa por la siguiente derivada:
$$
\frac{\partial \mathcal{L}}{\partial x_i^{\text{in}}} = \sum_{n=1}^N \frac{\partial \mathcal{L}}{\partial x_n^{\text{out}}} \cdot \frac{\partial x_n^{\text{out}}}{\partial x_i^{\text{in}}}, \quad \forall i
$$
Donde $\frac{\partial \mathcal{L}}{\partial x_i^{\text{in}}}$ representa c贸mo la entrada $i$ afecta sobre la p茅rdida total, $\frac{\partial \mathcal{L}}{\partial x_n^{\text{out}}}$ c贸mo cada salida $j$ afecta sobre la p茅rdida total y $\frac{\partial x_n^{\text{out}}}{\partial x_i^{\text{in}}}$ c贸mo la entrada $i$ afecta sobre cada salida $j$. Con esto, se puede actualizar el gradiente de las entradas durante el back-propagation.



"""

class FullyConnectedLayer:

    def __init__(self, n_in, n_out, neuron_class=NeuronNN, **kwargs):
        self.n_in, self.n_out = n_in, n_out
        self.neurons = [neuron_class(n_in) if (kwargs == {}) else neuron_class(n_in, **kwargs) for _ in range(n_out)]
        self.xin = None  # input, shape (n_in,)
        self.xout = None  # output, shape (n_out,)
        self.dloss_dxin = None  # d loss / d xin, shape (n_in,)
        self.zero_grad()

    def __call__(self, xin):
        # forward pass
        self.xin = xin
        self.xout = np.array([nn(self.xin) for nn in self.neurons])
        return self.xout

    def zero_grad(self, which=None):
        # reset gradients to zero
        if which is None:
            which = ['xin', 'weights', 'bias']
        for w in which:
            if w == 'xin':  # reset layer's d loss / d xin
                self.dloss_dxin = np.zeros(self.n_in)
            elif w == 'weights':  # reset d loss / dw to zero for every neuron
                for nn in self.neurons:
                    nn.dloss_dw = np.zeros((self.n_in, self.neurons[0].n_weights_per_edge))
            elif w == 'bias':  # reset d loss / db to zero for every neuron
                for nn in self.neurons:
                    nn.dloss_dbias = 0
            else:
                raise ValueError('input \'which\' value not recognized')

    def update_grad(self, dloss_dxout):
        # update gradients by chain rule
        for ii, dloss_dxout_tmp in enumerate(dloss_dxout):
            # update layer's d loss / d xin via chain rule
            # note: account for all possible xin -> xout -> loss paths!
            self.dloss_dxin += self.neurons[ii].dxout_dxin * dloss_dxout_tmp
            # update neuron's d loss / dw and d loss / d bias
            self.neurons[ii].update_dloss_dw_dbias(dloss_dxout_tmp)
        return self.dloss_dxin

"""Sea ***y*** la salida de la 煤ltima capa, es necesario calcular la p茅rdida para evaluar qu茅 tan cerca est谩 la predicci贸n realizada respecto a las etiquetas reales $y^{train}$.

*   Para regresi贸n se tiene la clase ***SquaredLosss***, que busca la p茅rdida se calcula mediante la diferencia cuadr谩tica, midiendo distancia entre predicciones y valores reales.
*   Para clasificaci贸n se tiene la clase ***CrossEntropyLoss***, que utiliza la p茅rdida de entrop铆a cruzada. Esto mide qu茅 tan bien la red identifica la categor铆a correcta. Con esto, se busca que la probabilidad asociada a la clase correcta sea la m谩s alta, utilizando el softmax en las salidas de la red.

La idea del c谩lculo de este error es ajustar los parametros de la red durante su entrenamiento.


"""

class Loss:

    def __init__(self, n_in):
        self.n_in = n_in
        self.y, self.dloss_dy, self.loss, self.y_train = None, None, None, None

    def __call__(self, y, y_train):
        # y: output of network
        # y_train: ground truth
        self.y, self.y_train = np.array(y), y_train
        self.get_loss()
        self.get_dloss_dy()
        return self.loss

    def get_loss(self):
        # compute loss l(y, y_train)
        pass

    def get_dloss_dy(self):
        # compute gradient of loss wrt y
        pass


class SquaredLoss(Loss):

    def get_loss(self):
        # compute loss l(xin, y)
        self.loss = np.mean(np.power(self.y - self.y_train, 2))

    def get_dloss_dy(self):
        # compute gradient of loss wrt xin
        self.dloss_dy = 2 * (self.y - self.y_train) / self.n_in


class CrossEntropyLoss(Loss):

    def get_loss(self):
        # compute loss l(xin, y)
        self.loss = - np.log(np.exp(self.y[self.y_train[0]]) / sum(np.exp(self.y)))

    def get_dloss_dy(self):
        # compute gradient of loss wrt xin
        self.dloss_dy = np.exp(self.y) / sum(np.exp(self.y))
        self.dloss_dy[self.y_train] -= 1

"""Finalmente, se finaliza apilando una cantidad arbitraria de capas para formar una red de propagaci贸n completamente conectada.

La clase ***FeedForward*** implementa una red neuronal de tipo feed-forward completamente conectada, permitiendo realizar el entrenamiento mediante pasos de propagaci贸n hacia adelante y retropropagaci贸n.


*   En la propagaci贸n hacia adelante, los datos de entrenamiento $x^{train}$ pasan a trav茅s de las capas de la red. Cada capa calcula sus salidas $x^{out}$.
*   En la retropropagaci贸n se calcula el gradiente de la p茅rdida
$$
\delta_i = \frac{\partial \mathcal{L}}{\partial x_i^{\text{in}}} = \sum_{n=1}^N \delta_n \cdot \frac{\partial x_n^{\text{out}}}{\partial x_i^{\text{in}}},
$$
donde $\delta_i$ se propaga desde la 煤ltima capa hasta la primera.
*   El descenso por gradiente permite que los par谩metros de la red se actualicen.$$
W_{ij} \gets W_{ij} - \epsilon \cdot \frac{\partial \mathcal{L}}{\partial W_{ij}}, \quad b_j \gets b_j - \epsilon \cdot \frac{\partial \mathcal{L}}{\partial b_j},
$$
$\epsilon$ corresponde a la tasa de aprendizaje, la cual permite controlar la dimensi贸n de las actualizaciones a realizar.

*   En cada iteraci贸n, se computa la p茅rdida total $\mathcal{L}$ acumulada sobre todas las muestras de entrenamiento, y se ajustan los par谩metros hasta alcanzar un criterio de convergencia o un n煤mero m谩ximo de iteraciones.
"""

from tqdm import tqdm

class FeedForward:
    def __init__(self, layer_len, eps=.0001, seed=None, loss=SquaredLoss, **kwargs):
        self.seed = np.random.randint(int(1e4)) if seed is None else int(seed)
        np.random.seed(self.seed)
        self.layer_len = layer_len
        self.eps = eps
        self.n_layers = len(self.layer_len) - 1
        self.layers = [FullyConnectedLayer(layer_len[ii], layer_len[ii + 1], **kwargs) for ii in range(self.n_layers)]
        self.loss = loss(self.layer_len[-1])
        self.loss_hist = None

    def __call__(self, x):
        # forward pass
        x_in = x
        for ll in range(self.n_layers):
            x_in = self.layers[ll](x_in)
        return x_in

    def backprop(self):
        # gradient backpropagation
        delta = self.layers[-1].update_grad(self.loss.dloss_dy)
        for ll in range(self.n_layers - 1)[::-1]:
            delta = self.layers[ll].update_grad(delta)

    def gradient_descent_par(self):
        # update parameters via gradient descent
        for ll in self.layers:
            for nn in ll.neurons:
                nn.gradient_descent(self.eps)

    def train(self, x_train, y_train, n_iter_max=10000, loss_tol=.1):
        self.loss_hist = np.zeros(n_iter_max)
        x_train, y_train = np.array(x_train), np.array(y_train)
        assert x_train.shape[0] == y_train.shape[0], 'x_train, y_train must contain the same number of samples'
        assert x_train.shape[1] == self.layer_len[0], 'shape of x_train is incompatible with first layer'

        pbar = tqdm(range(n_iter_max))
        for it in pbar:
            loss = 0  # reset loss
            for ii in range(x_train.shape[0]):
                x_out = self(x_train[ii, :])  # forward pass
                loss += self.loss(x_out, y_train[ii, :])  # accumulate loss
                self.backprop()  # backward propagation
                [layer.zero_grad(which=['xin']) for layer in self.layers]  # reset gradient wrt xin to zero
            self.loss_hist[it] = loss
            if (it % 10) == 0:
                pbar.set_postfix_str(f'loss: {loss:.3f}')  #
            if loss < loss_tol:
                pbar.set_postfix_str(f'loss: {loss:.3f}. Convergence has been attained!')
                self.loss_hist = self.loss_hist[: it]
                break
            self.gradient_descent_par()  # update parameters
            [layer.zero_grad(which=['weights', 'bias']) for layer in self.layers]  # reset gradient wrt par to zero

"""Del tutorial siguiente, se debe considerar lo siguiente.


> En la pr谩ctica, los datos de entrenamiento se entregan en lotes, por lo que la p茅rdida y los gradientes correspondientes se suman en todos los datos del lote. Dado que los gradientes se acumulan durante el paso hacia atr谩s, deben reiniciarse a cero despu茅s de cada lote.

### Reproducci贸n del tutorial.

En este ultimo paso, se reproducir谩 el ejemplo del tutorial, utilizando un problema de **regresi贸n de una dimensi贸n simple**, entrenando las KAN y el MLP.

#### Ejemplo 1

Se genera un conjunto de datos basados en una funci贸n sinuidal amortiguada. Se tienen entradas $x_{train}$ y salidas $y_{train}$. Se entrena una red KAN y una MLP.
"""

n_iter_train_1d = 500 #N煤mero m谩ximo de iteraciones de entrenamiento.
loss_tol_1d = .05
seed = 476

# Generaci贸n de datos de entrenamiento: Funci贸n sinusoidal amortiguada.
x_train = np.linspace(-1, 1, 50).reshape(-1, 1)
y_train = .5 * np.sin(4 * x_train) * np.exp(-(x_train+1)) + .5  # damped sinusoid

# KAN training
kan_1d = FeedForward([1, 2, 2, 1],  # layer size
                  eps=.01,  # gradient descent parameter
                  n_weights_per_edge=7,  # n. edge functions
                  neuron_class=NeuronKAN,
                  x_bounds=[-1, 1],  # input domain bounds
                  get_edge_fun=get_bsplines,  # edge function type (B-splines ot Chebyshev)
                  seed=seed,
                  weights_range=[-1, 1])
kan_1d.train(x_train,
          y_train,
          n_iter_max=n_iter_train_1d,
          loss_tol=loss_tol_1d)

# MLP training
mlp_1d = FeedForward([1, 13, 1],  # layer size
                  eps=.005,  # gradient descend parameter
                  activation=relu,  # activation type (ReLU, tanh or sigmoid)
                  neuron_class=NeuronNN,
                  seed=seed,
                  weights_range=[-.5, .5])
mlp_1d.train(x_train,
             y_train,
             n_iter_max=n_iter_train_1d,
             loss_tol=loss_tol_1d)

"""Se visualiza el proceso mediante el siguiente bloque de c贸digo."""

import matplotlib.pyplot as plt # import the matplotlib library and assign it to the alias 'plt'

# Define the color_plots dictionary
color_plots = {
    'dataset': 'blue',  # Example color for the dataset
    'kan': 'red',       # Example color for KAN
    'mlp': 'green'      # Example color for MLP
}

# Regression on training data
fig, ax = plt.subplots(figsize=(4,3.2))
x_plot = np.linspace(x_train[0], x_train[-1], 1000).reshape(-1, 1)
ax.plot(x_train, y_train, 'o', color=color_plots['dataset'], label='training dataset')
ax.plot(x_plot, [kan_1d(x) for x in x_plot], color=color_plots['kan'], label='KAN')
ax.plot(x_train, [kan_1d(x) for x in x_train], 'x', color=color_plots['kan'], fillstyle='none')
ax.plot(x_plot, [mlp_1d(x) for x in x_plot], color=color_plots['mlp'], label='MLP')
ax.plot(x_train, [mlp_1d(x) for x in x_train], 'd', color=color_plots['mlp'], fillstyle='none')
ax.set_xlabel('input feature', fontsize=13)
ax.set_title('Regression', fontsize=15)
ax.legend()
ax.grid()
fig.tight_layout()
plt.show()
#fig.savefig(folder_fig + 'regr1D.png', dpi=500)

"""Las predicciones para KAN se muestran en rojo, y en verde para MLP.
 Se puede observar que las curvas para KAN varian de forma m谩s compleja, esto se debe a las funciones de borde (B-splines). La convergencia en KAN se obtuvo m谩s r谩pido que para MLP, esto se puede observar en la siguiente imagen:

 ![image.png](data:image/png;base64,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)

#### Ejemplo 2
A continuaci贸n se presenta un problema de ***regresi贸n 2D*** (se tienen dos entradas) un poco m谩s complejo. Los valores de salida se calculan al evaluar la funci贸n en cada punto de la malla.
"""

def fun2d(X1, X2):
    return X1 * np.power(X2, .5)

X1, X2 = np.meshgrid(np.linspace(0, .8, 8), np.linspace(0, 1, 10))
Y_training = fun2d(X1, X2)

x_train2d = np.concatenate((X1.reshape(-1, 1), X2.reshape(-1, 1)), axis=1)
y_train2d = Y_training.reshape(-1, 1)

f, a = plt.subplots(figsize=(3,3))
a.set_xlabel('input feature 1')
a.set_ylabel('input feature 2')
a.pcolor(X1, X2, Y_training)
a.set_title('Training data')
f.tight_layout()
plt.show()

"""El mapa de calor anterior representa las dependencias entre las caracter铆sticas ***x1*** y ***x2***.
Se entrena la red KAN y MLP.
"""

n_iter_train_2d = 500
loss_tol_2d = .1
seed = 476

#KAN
kan_2d = FeedForward([2, 2, 1],  # layer size
                  eps=.02,  # gradient descent parameter
                  n_weights_per_edge=10,  # n. edge functions
                  neuron_class=NeuronKAN,
                  x_bounds=[-1, 1],  # input domain bounds
                  get_edge_fun=get_bsplines,  # edge function type (B-splines ot Chebyshev)
                  seed=seed,
                  weights_range=[-1, 1])
kan_2d.train(x_train2d,
          y_train2d,
          n_iter_max=n_iter_train_2d,
          loss_tol=loss_tol_2d)

#MLP
mlp_2d = FeedForward([2, 6, 1],  # layer size
                     eps=.0025,  # gradient descend parameter
                     activation=relu,  # activation type (ReLU, tanh or sigmoid)
                     neuron_class=NeuronNN,
                     seed=seed,
                     weights_range=[-.1, .1])
mlp_2d.train(x_train2d,
             y_train2d,
             n_iter_max=n_iter_train_2d,
             loss_tol=loss_tol_2d)

"""El siguiente bloque es para la visualizaci贸n de los resultados."""

Y_kan = np.array([kan_2d(xx) for xx in x_train2d])
Y_mlp = np.array([mlp_2d(xx) for xx in x_train2d])

f, a = plt.subplots(1, 3, figsize=(11,3))

vmin, vmax = min(Y_training.flatten()), max(Y_training.flatten())

im0 = a[0].pcolor(X1, X2, Y_training, vmin=vmin, vmax=vmax)
f.colorbar(im0, ax=a[0])
a[0].set_title('Training data')
a[0].set_xlabel('input feature 1')
a[0].set_ylabel('input feature 2')

im1 = a[1].pcolor(X1, X2, Y_kan.reshape(X1.shape), vmin=vmin, vmax=vmax)
f.colorbar(im1, ax=a[1])
a[1].set_title('KAN regression')
a[1].set_xlabel('input feature 1')
a[1].set_ylabel('input feature 2')

im2 = a[2].pcolor(X1, X2, Y_mlp.reshape(X1.shape), vmin=vmin, vmax=vmax)
f.colorbar(im2, ax=a[2])
a[2].set_title('MLP regression')
a[2].set_xlabel('input feature 1')
a[2].set_ylabel('input feature 2')

f.tight_layout()
plt.show()
# f.savefig(folder_fig + 'regr2D.png', dpi=500)

fig1, ax1 = plt.subplots(figsize=(4,3))
ax1.plot(kan_2d.loss_hist, '-', color=color_plots['kan'], label='KAN')
ax1.plot(mlp_2d.loss_hist, '-', color=color_plots['mlp'], label='MLP')
ax1.plot(loss_tol_2d * np.ones(max(len(mlp_2d.loss_hist), len(kan_2d.loss_hist))), '--k')
ax1.grid()
ax1.set_ylabel('squared loss')
ax1.set_xlabel('iteration', fontsize=13)
ax1.legend()
ax1.set_title('Loss evolution')
plt.show()

"""Como se puede observar en la imagen generada,  un mapa de calor para los datos de entrenamiento originales y los valores predichos por los modelos KAN y MLP.
*   Training data: Representa los valores reales de la funci贸n objetivo.
*   KAN regression: Muestra la predicci贸n de la red KAN, que ajusta los datos con gran precisi贸n.
*   MLP regression: Muestra la predicci贸n del MLP, que tambi茅n sigue la tendencia general pero puede ser menos preciso en regiones complejas.

Se puede observar que KAN captura mejor las relaciones no lineales debido a las transformaciones no lineales. En MLP se observa una generalizaci贸n m谩s limitada. Adem谩s, KAN alcanz贸 la convergencia m谩s rapido que MLP.

#### Ejemplo 3
Se concluye con un problema de ***clasificaci贸n en el conjunto de datos en forma de media luna de scikit-learn***. Los datos se observan en el gr谩fico posterior, coloreados referentes a la clase a la que pertenecen.
"""

from sklearn import datasets

n_samples = 50
noise = 0.1
x_train_cl, y_train_cl = datasets.make_moons(n_samples=n_samples, noise=noise)
# normalize between -1 and 1
x_train_cl[:, 0] = (x_train_cl[:, 0] - min(x_train_cl[:, 0])) / max(x_train_cl[:, 0] - min(x_train_cl[:, 0])) * 2 - 1
x_train_cl[:, 1] = (x_train_cl[:, 1] - min(x_train_cl[:, 1])) / max(x_train_cl[:, 1] - min(x_train_cl[:, 1])) * 2 - 1

fig, ax = plt.subplots(figsize=(4,3))
ax.scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
ax.set_xlabel('input feature 1')
ax.set_ylabel('input feature 2')
ax.grid()
ax.set_title("Training data")
plt.show()

"""A continuaci贸n se realiza el entrenamiento de los modelos MLP(dos capas ocultas de 10 neuronas cada una) y KAN (una capa de 2 neuronas). Para ambos se utiliza entrop铆a cruzada como funci贸n de perdida ya que es un problema de clasificaci贸n."""

#parametros
n_iter_train_cl = int(1e3)
loss_tol_cl = 1.5
seed = 476

#MLP
mlp_cl = FeedForward([2, 10, 10, 2],  # layer size
                     eps=.01,  # gradient descend parameter
                     activation=tanh_act,  # activation type (relu, tanh_act or sigmoid_act)
                     neuron_class=NeuronNN,
                     loss=CrossEntropyLoss,
                     seed=seed,
                     weights_range=[-1, 1])
mlp_cl.train(x_train_cl,
             y_train_cl.reshape(-1, 1),
             n_iter_max=n_iter_train_cl,
             loss_tol=loss_tol_cl)

#KAN
kan_cl = FeedForward([2, 2],  # layer size
                     eps=.02,  # gradient descent parameter
                     n_weights_per_edge=8,  # n. edge functions
                     neuron_class=NeuronKAN,
                     loss=CrossEntropyLoss,
                     x_bounds=[-1, 1],  # input domain bounds
                     get_edge_fun=get_bsplines,  # edge function type (B-splines ot Chebyshev)
                     seed=seed,
                     weights_range=[-1, 1])
kan_cl.train(x_train_cl,
             y_train_cl.reshape(-1, 1),
             n_iter_max=n_iter_train_cl,
             loss_tol=loss_tol_cl)

#plot
def softmax(vec):
    return np.exp(vec) / sum(np.exp(vec))

X1_cl, X2_cl = np.meshgrid(np.linspace(-1, 1, 40), np.linspace(-1, 1, 50))
x_cl = np.concatenate((X1_cl.reshape(-1, 1), X2_cl.reshape(-1, 1)), axis=1)

Y_kan_cl = np.array([softmax(kan_cl(x))[1] for x in x_cl]).reshape(X1_cl.shape)
Y_mlp_cl = np.array([softmax(mlp_cl(x))[1] for x in x_cl]).reshape(X1_cl.shape)

fig_cl, ax_cl = plt.subplots(1, 3, figsize=(12,3))
# vmin, vmax = min(Y_training.flatten()), max(Y_training.flatten())

ax_cl[0].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
ax_cl[0].grid()
ax_cl[0].set_title('Training data')
ax_cl[0].set_xlabel('input feature 1')
ax_cl[0].set_ylabel('input feature 2')

im0 = ax_cl[1].pcolor(X1_cl, X2_cl, Y_kan_cl, vmin=0, vmax=1, cmap=plt.cm.bwr)
ax_cl[1].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
ax_cl[1].set_title('KAN classification')
ax_cl[1].set_xlabel('input feature 1')
ax_cl[1].set_ylabel('input feature 2')

im1 = ax_cl[2].pcolor(X1_cl, X2_cl, Y_mlp_cl, vmin=0, vmax=1, cmap=plt.cm.bwr)
ax_cl[2].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
ax_cl[2].set_title('MLP classification')
ax_cl[2].set_xlabel('input feature 1')
ax_cl[2].set_ylabel('input feature 2')

fig_cl.colorbar(im1, ax=ax_cl[0])
fig_cl.colorbar(im1, ax=ax_cl[1])
fig_cl.colorbar(im1, ax=ax_cl[2])
fig_cl.tight_layout()
plt.show()
# fig_cl.savefig(folder_fig + 'classification.png', dpi=500)

"""Se observan los datos de entrenamiento mediante un mapa de calior que ilustra la probabilidad asignada por los modelos para cada clase en el dominio. Los puntos representan los datos de entrenamiento y se observa c贸mo ambos modelos trazan los l铆mites de decisi贸n.
Se observa que KAN puede capturar patrones m谩s complejos debido a sus transformaciones basadas en B-splines, tal como ha ocurrido en los ejemplos anteriores.

## Item 2. Modificaci贸n y Comparaci贸n de Resultados

### Ejemplo 1

Para este apartado se realiza el ejemplo de regresi贸n, comparando con el realizado por el tutorial mediante la creaci贸n de un ejemplo de regresi贸n para datos con una distribuci贸n compleja y otra lineal.

En este proceso, se generan datos con una distribuci贸n c煤bica con ruido introducido para observar c贸mo los modelos KAN y MLP responden a estos datos. Posteriormente se observan tres gr谩ficos: Los datos generados sobre el eje $x$ e $y$, Las curvas generadas por el modelo por sobre los datos, y la evoluci贸n del valor de LOSS para ambos modelos mediante las iteraciones de entrenamiento.
"""

# @title Datos con tendencia c煤bica y entrenamiento.
import numpy as np
import matplotlib.pyplot as plt

# Colores para gr谩ficos
color_plots = {'dataset': 'blue', 'kan': 'orange', 'mlp': 'green'}

# Generar un nuevo conjunto de datos (distribuci贸n polin贸mica con ruido)
np.random.seed(42)
x_train = np.linspace(-1, 1, 50).reshape(-1, 1)
y_train = 0.8 * (x_train**3) - 0.5 * (x_train**2) + 0.3 * x_train + 0.2  # funci贸n c煤bica
y_train += 0.1 * np.random.normal(size=y_train.shape)  # agregar ruido

# Par谩metros de entrenamiento
n_iter_train_1d = 500
loss_tol_1d = 0.05
seed = 476

# Entrenamiento de KAN
kan_1d = FeedForward(
    [1, 2, 2, 1],  # tama帽o de capas
    eps=0.01,  # par谩metro de descenso de gradiente
    n_weights_per_edge=7,  # n煤mero de funciones por conexi贸n
    neuron_class=NeuronKAN,
    x_bounds=[-1, 1],  # l铆mites del dominio de entrada
    get_edge_fun=get_bsplines,  # tipo de funciones de borde (B-splines o Chebyshev)
    seed=seed,
    weights_range=[-1, 1]
)
kan_1d.train(x_train, y_train, n_iter_max=n_iter_train_1d, loss_tol=loss_tol_1d)

# Entrenamiento de MLP
mlp_1d = FeedForward(
    [1, 13, 1],  # tama帽o de capas
    eps=0.005,  # par谩metro de descenso de gradiente
    activation=relu,  # tipo de activaci贸n (ReLU, tanh o sigmoide)
    neuron_class=NeuronNN,
    seed=seed,
    weights_range=[-0.5, 0.5]
)
mlp_1d.train(x_train, y_train, n_iter_max=n_iter_train_1d, loss_tol=loss_tol_1d)



# Crear los gr谩ficos
fig, ax = plt.subplots(1, 3, figsize=(15, 4))

# Primer gr谩fico: Datos de entrenamiento
ax[0].plot(x_train, y_train, 'o', color=color_plots['dataset'], markersize=4, label='Training Data')
ax[0].set_title('Training Data (Linear)')
ax[0].grid()
ax[0].legend()

# Segundo gr谩fico: Resultados KAN vs MLP
x_plot = np.linspace(-1, 1, 1000).reshape(-1, 1)  # puntos para predicciones
y_kan_pred = np.array([kan_1d(x) for x in x_plot])  # predicci贸n con KAN
y_mlp_pred = np.array([mlp_1d(x) for x in x_plot])  # predicci贸n con MLP

ax[1].plot(x_train, y_train, 'o', color=color_plots['dataset'], markersize=4, label='Training Data')  # Reducir tama帽o de los puntos
ax[1].plot(x_plot, y_kan_pred, '-', color=color_plots['kan'], linewidth=2, label='KAN')  # Aumentar grosor de la l铆nea
ax[1].plot(x_plot, y_mlp_pred, '-', color=color_plots['mlp'], linewidth=2, label='MLP')  # Aumentar grosor de la l铆nea
ax[1].set_title('Regression: KAN vs MLP')
ax[1].grid()
ax[1].legend()

# Tercer gr谩fico: Evoluci贸n del loss
ax[2].plot(kan_1d.loss_hist, '-', color=color_plots['kan'], linewidth=1.5, label='KAN Loss')
ax[2].plot(mlp_1d.loss_hist, '-', color=color_plots['mlp'], linewidth=1.5, label='MLP Loss')
ax[2].plot(loss_tol_1d * np.ones(max(len(mlp_1d.loss_hist), len(kan_1d.loss_hist))), '--k', label='Loss Tolerance')
ax[2].set_title('Loss Evolution')
ax[2].set_xlabel('Iterations')
ax[2].set_ylabel('Loss')
ax[2].grid()
ax[2].legend()

# Ajustar el dise帽o
fig.tight_layout()
plt.show()

"""Para los datos generados, se observa que el modelo KAN representa de manera m谩s precisa los datos en comparaci贸n al modelo MLP. Algo interesante a analizar es que KAN inicia con un Loss elevado, pero este valor decrece r谩pidamente a mayor cantidad de iteraciones de entrenamiento, alcanzando una precisi贸n significativamente mejor que la obtenida por MLP.

Esto se explica por la forma en que ambos algoritmos procesan los datos. KAN utiliza las funci贸nes borde (b-spline), lo que le permite representar relaciones m谩s complejas y no lineales entre las entradas, por lo que el modelo se ajusta mejor a esta distribuci贸n de los datos, a diferencia de MLP aproxima las relaciones de los datos con funciones m谩s simples, observando as铆 la relaci贸n de los datos con forma lineal hecha por MLP menos representativa de los datos.

Se presenta la siguiente imagen, la cual son los resultados obtenidos del entrenamiento para el primer ejemplo de regresi贸n realizado en el tutorial con el fin de su posterior comparaci贸n y an谩lisis.

![image.png](data:image/png;base64,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)

Al observar los datos obtenidos en el ejemplo 1 del tutorial, se aprecia un caso muy similar al comentado recientemente. Si bien ambos alcanzaron una convergencia adecuada para el valor de loss (Loss = 0,05), MLP tardo m谩s iteraciones en alcanzar esta convergencia. Para ambas distribuciones complejas de los datos generados se obtuvo una mejora en el valor de LOSS m谩s rapida para KAN que para MLP. Nuevamente se entiende que esto puede deberse a la capacidad de KAN de detectar comportamientos complejos en los datos, donde para ambos ejemplos obtuvo una forma con curvas m谩s suaves y para MLP un comportamiento lineal.

De ambos ejemplos se puede entender que KAN no solo es m谩s eficiente en la cantidad de iteraciones necesarias para converger al valor definido de loss, si no que tambi茅n demuestra mayor capacidad para ajustarse a distribuciones complejas. De aqu铆 surge la siguiente pregunta:

**驴KAN es mejor que MLP en todo tipo de distribuci贸n de datos?**


Para responder a lo anterior, se genera un ejemplo con una distribuci贸n lineal $y = 2x+1$, con ruido introducido.
"""

# @title Datos con tendencia c煤bica y entrenamiento.
import numpy as np
import matplotlib.pyplot as plt

# Colores para gr谩ficos
color_plots = {'dataset': 'blue', 'kan': 'orange', 'mlp': 'green'}

# Generar un nuevo conjunto de datos (distribuci贸n polin贸mica con ruido)
np.random.seed(42)
x_train = np.linspace(-1, 1, 50).reshape(-1, 1)
y_train = 0.8 * (x_train**3) - 0.5 * (x_train**2) + 0.3 * x_train + 0.2  # funci贸n c煤bica
y_train += 0.1 * np.random.normal(size=y_train.shape)  # agregar ruido

# Par谩metros de entrenamiento
n_iter_train_1d = 500
loss_tol_1d = 0.05
seed = 476

# Entrenamiento de KAN
kan_1d = FeedForward(
    [1, 2, 2, 1],  # tama帽o de capas
    eps=0.01,  # par谩metro de descenso de gradiente
    n_weights_per_edge=7,  # n煤mero de funciones por conexi贸n
    neuron_class=NeuronKAN,
    x_bounds=[-1, 1],  # l铆mites del dominio de entrada
    get_edge_fun=get_bsplines,  # tipo de funciones de borde (B-splines o Chebyshev)
    seed=seed,
    weights_range=[-1, 1]
)
kan_1d.train(x_train, y_train, n_iter_max=n_iter_train_1d, loss_tol=loss_tol_1d)

# Entrenamiento de MLP
mlp_1d = FeedForward(
    [1, 13, 1],  # tama帽o de capas
    eps=0.005,  # par谩metro de descenso de gradiente
    activation=relu,  # tipo de activaci贸n (ReLU, tanh o sigmoide)
    neuron_class=NeuronNN,
    seed=seed,
    weights_range=[-0.5, 0.5]
)
mlp_1d.train(x_train, y_train, n_iter_max=n_iter_train_1d, loss_tol=loss_tol_1d)



# Crear los gr谩ficos
fig, ax = plt.subplots(1, 3, figsize=(15, 4))

# Primer gr谩fico: Datos de entrenamiento
ax[0].plot(x_train, y_train, 'o', color=color_plots['dataset'], markersize=4, label='Training Data')
ax[0].set_title('Training Data (Linear)')
ax[0].grid()
ax[0].legend()

# Segundo gr谩fico: Resultados KAN vs MLP
x_plot = np.linspace(-1, 1, 1000).reshape(-1, 1)  # puntos para predicciones
y_kan_pred = np.array([kan_1d(x) for x in x_plot])  # predicci贸n con KAN
y_mlp_pred = np.array([mlp_1d(x) for x in x_plot])  # predicci贸n con MLP

ax[1].plot(x_train, y_train, 'o', color=color_plots['dataset'], markersize=4, label='Training Data')  # Reducir tama帽o de los puntos
ax[1].plot(x_plot, y_kan_pred, '-', color=color_plots['kan'], linewidth=2, label='KAN')  # Aumentar grosor de la l铆nea
ax[1].plot(x_plot, y_mlp_pred, '-', color=color_plots['mlp'], linewidth=2, label='MLP')  # Aumentar grosor de la l铆nea
ax[1].set_title('Regression: KAN vs MLP')
ax[1].grid()
ax[1].legend()

# Tercer gr谩fico: Evoluci贸n del loss
ax[2].plot(kan_1d.loss_hist, '-', color=color_plots['kan'], linewidth=1.5, label='KAN Loss')
ax[2].plot(mlp_1d.loss_hist, '-', color=color_plots['mlp'], linewidth=1.5, label='MLP Loss')
ax[2].plot(loss_tol_1d * np.ones(max(len(mlp_1d.loss_hist), len(kan_1d.loss_hist))), '--k', label='Loss Tolerance')
ax[2].set_title('Loss Evolution')
ax[2].set_xlabel('Iterations')
ax[2].set_ylabel('Loss')
ax[2].grid()
ax[2].legend()

# Ajustar el dise帽o
fig.tight_layout()
plt.show()

# @title Datos con distribuci贸n lineal
import numpy as np
import matplotlib.pyplot as plt

# Colores para gr谩ficos
color_plots = {'dataset': 'blue', 'kan': 'orange', 'mlp': 'green'}

# Generar datos lineales con ruido
np.random.seed(42)
x_train_linear = np.linspace(-1, 1, 50).reshape(-1, 1)  # 50 puntos entre -1 y 1
y_train_linear = 2 * x_train_linear + 1  # y = 2x + 1
y_train_linear += 0.1 * np.random.normal(size=y_train_linear.shape)  # agregar ruido

# Par谩metros de entrenamiento
n_iter_train_linear = 500
loss_tol_linear = 0.05
seed = 476

# Entrenamiento de KAN
kan_linear = FeedForward(
    [1, 2, 2, 1],  # tama帽o de capas
    eps=0.01,  # par谩metro de descenso de gradiente
    n_weights_per_edge=7,  # n煤mero de funciones por conexi贸n
    neuron_class=NeuronKAN,
    x_bounds=[-1, 1],  # l铆mites del dominio de entrada
    get_edge_fun=get_bsplines,  # tipo de funciones de borde (B-splines o Chebyshev)
    seed=seed,
    weights_range=[-1, 1]
)
kan_linear.train(x_train_linear, y_train_linear, n_iter_max=n_iter_train_linear, loss_tol=loss_tol_linear)

# Entrenamiento de MLP
mlp_linear = FeedForward(
    [1, 13, 1],  # tama帽o de capas
    eps=0.005,  # par谩metro de descenso de gradiente
    activation=relu,  # tipo de activaci贸n (ReLU, tanh o sigmoide)
    neuron_class=NeuronNN,
    seed=seed,
    weights_range=[-0.5, 0.5]
)
mlp_linear.train(x_train_linear, y_train_linear, n_iter_max=n_iter_train_linear, loss_tol=loss_tol_linear)


# Visualizar los datos y los resultados en una fila de gr谩ficos
fig, ax = plt.subplots(1, 3, figsize=(15, 4))  # Crear una figura con 3 subgr谩ficos uno al lado del otro

# Primer gr谩fico: Visualizaci贸n de los datos de entrenamiento
ax[0].plot(x_train_linear, y_train_linear, 'o', color=color_plots['dataset'], label='Training Data')
ax[0].set_title('Training Data (Linear)')
ax[0].grid()
ax[0].legend()

# Segundo gr谩fico: Resultados KAN vs MLP
x_plot = np.linspace(-1, 1, 1000).reshape(-1, 1)  # puntos para predicciones
y_kan_pred = np.array([kan_linear(x) for x in x_plot])  # predicci贸n con KAN
y_mlp_pred = np.array([mlp_linear(x) for x in x_plot])  # predicci贸n con MLP

# Ajustar tama帽o de los puntos de entrenamiento y grosor de las l铆neas
ax[1].plot(x_train_linear, y_train_linear, 'o', color=color_plots['dataset'], markersize=4, label='Training Data')  # Reducir tama帽o de los puntos
ax[1].plot(x_plot, y_kan_pred, '-', color=color_plots['kan'], linewidth=2, label='KAN')  # Aumentar grosor de la l铆nea
ax[1].plot(x_plot, y_mlp_pred, '-', color=color_plots['mlp'], linewidth=2, label='MLP')  # Aumentar grosor de la l铆nea
ax[1].set_title('Linear Regression: KAN vs MLP')
ax[1].grid()
ax[1].legend()

# Tercer gr谩fico: Comportamiento del Loss vs Iteraciones
ax[2].plot(range(len(kan_linear.loss_hist)), kan_linear.loss_hist, color=color_plots['kan'], label='KAN Loss', linewidth=2)
ax[2].plot(range(len(mlp_linear.loss_hist)), mlp_linear.loss_hist, color=color_plots['mlp'], label='MLP Loss', linewidth=2)
ax[2].set_title('Loss vs Iterations')
ax[2].set_xlabel('Iterations')
ax[2].set_ylabel('Loss')
ax[2].grid()
ax[2].legend()

# Ajustar el dise帽o
fig.tight_layout()
plt.show()

"""En este caso, KAN no ofrece ventajas significativas a diferencia de los casos presentados anteriormente. MLP genera una mejor representaci贸n gracias a su arquitectura m谩s simple, siendo capaz de ajustarse con mayor precisi贸n a la tendencia lineal de los datos.

 Como KAN introduce una complejidad adicional, su representaci贸n tiende a agregar curvas o patrones innecesario debido al uso de las funciones borde. Esto se puede observar en el gr谩fico, donde a partir del punto x1=0, desv铆a su forma del comportamiento esperado de los datos. Esto resulta en una perdida adicional y un loss con un valor mucho m谩s alto que el obtenido para MLP.

  En base al gr谩fico loss vs Iterations observado, MLP tiene un Loss mejor que KAN para muchas iteraciones, adem谩s de una r谩pida convergencia del valor de p茅rdida, solidificando lo fundamentado anteriormente.

  Otra observaci贸n a realizar es que MLP no toma valores negativos para $y$, esto puede deberse a la funci贸n de activaci贸n RelU utilizada, la cual toma los valores negativos como 0 a lo largo de la propagaci贸n hacia adelante.

### Ejemplo 2
Para este segundo apartado se realiza el ejemplo de regresi贸n 2D, comparandolo con el realizado en el tutorial junto con los nuevos datos de entrenamiento utilizando distribuci贸n lineal.

Este c贸digo genera una visualizaci贸n completa de los datos y resultados obtenidos al aplicar los modelos KAN y MLP sobre un conjunto de datos distribuidos linealmente.

El c贸digo siguiente genera datos distribuidos linealmente. Se les aplica KAN y MLP para su posterior comparaci贸n con el Ejemplo 2 del tutorial. Se presentan cuatro gr谩ficos: los datos de generados, las predicciones realizadas por el modelo KAN, las predicciones del modelo MLP y la evoluci贸n de la p茅rdida ante iteraciones del entrenamiento de ambos modelos.

Dado que para el ejemplo 1 ya se realizaron ejemplos de regresi贸n ante datos con distribuci贸n compleja y lineal, en este apartado se hace hincapi茅 unicamente en la regresi贸n con datos distribuidos linealmente para su posterior comparaci贸n con el ejemplo de regresi贸n con datos complejamente distribuidos del tutorial.
"""

# @title Datos con distribuci贸n lineal y aplicaci贸n de MLP y KAN.
import numpy as np
import matplotlib.pyplot as plt

# Cambiamos la funci贸n para generar una distribuci贸n lineal
def fun2d_linear(X1, X2):
    return 0.5 * X1 + 0.3 * X2

X1, X2 = np.meshgrid(np.linspace(0, .8, 8), np.linspace(0, 1, 10))
Y_training = fun2d_linear(X1, X2)

x_train2d = np.concatenate((X1.reshape(-1, 1), X2.reshape(-1, 1)), axis=1)
y_train2d = Y_training.reshape(-1, 1)

# Par谩metros de entrenamiento
n_iter_train_2d = 500
loss_tol_2d = 0.01
seed = 476

# KAN con datos lineales
kan_2d = FeedForward(
    [2, 2, 1],  # tama帽o de las capas
    eps=0.02,  # par谩metro de gradiente
    n_weights_per_edge=10,  # funciones por arista
    neuron_class=NeuronKAN,
    x_bounds=[-1, 1],  # l铆mites del dominio
    get_edge_fun=get_bsplines,  # funciones de base (B-splines)
    seed=seed,
    weights_range=[-1, 1]
)
kan_2d.train(
    x_train2d,
    y_train2d,
    n_iter_max=n_iter_train_2d,
    loss_tol=loss_tol_2d
)

# MLP con datos lineales para comparaci贸n
mlp_2d = FeedForward(
    [2, 6, 1],  # tama帽o de las capas
    eps=0.0025,  # par谩metro de gradiente
    activation=relu,  # tipo de activaci贸n
    neuron_class=NeuronNN,
    seed=seed,
    weights_range=[-0.1, 0.1]
)
mlp_2d.train(
    x_train2d,
    y_train2d,
    n_iter_max=n_iter_train_2d,
    loss_tol=loss_tol_2d
)


# C贸digo del bloque 2 (Gr谩ficos de los resultados)
Y_kan = np.array([kan_2d(xx) for xx in x_train2d])
Y_mlp = np.array([mlp_2d(xx) for xx in x_train2d])

# Crear una figura para concatenar las im谩genes
fig_concat, axs_concat = plt.subplots(1, 4, figsize=(16, 4))  # 4 gr谩ficos lado a lado

# Gr谩fico 1: Training Data (Bloque 1)
vmin, vmax = min(Y_training.flatten()), max(Y_training.flatten())
im0 = axs_concat[0].pcolor(X1, X2, Y_training, vmin=vmin, vmax=vmax, shading='auto')
fig_concat.colorbar(im0, ax=axs_concat[0])
axs_concat[0].set_title('Training Data')
axs_concat[0].set_xlabel('Input feature 1')
axs_concat[0].set_ylabel('Input feature 2')

# Gr谩fico 2: KAN regression (Bloque 2)
im1 = axs_concat[1].pcolor(X1, X2, Y_kan.reshape(X1.shape), vmin=vmin, vmax=vmax, shading='auto')
fig_concat.colorbar(im1, ax=axs_concat[1])
axs_concat[1].set_title('KAN Regression')
axs_concat[1].set_xlabel('Input feature 1')
axs_concat[1].set_ylabel('Input feature 2')

# Gr谩fico 3: MLP regression (Bloque 2)
im2 = axs_concat[2].pcolor(X1, X2, Y_mlp.reshape(X1.shape), vmin=vmin, vmax=vmax, shading='auto')
fig_concat.colorbar(im2, ax=axs_concat[2])
axs_concat[2].set_title('MLP Regression')
axs_concat[2].set_xlabel('Input feature 1')
axs_concat[2].set_ylabel('Input feature 2')

# Gr谩fico 4: Loss evolution (Bloque 3)
axs_concat[3].plot(kan_2d.loss_hist, '-', label='KAN', color='blue')  # Ajusta color seg煤n tu esquema
axs_concat[3].plot(mlp_2d.loss_hist, '-', label='MLP', color='orange')  # Ajusta color seg煤n tu esquema
axs_concat[3].plot(loss_tol_2d * np.ones(max(len(mlp_2d.loss_hist), len(kan_2d.loss_hist))), '--k')
axs_concat[3].grid()
axs_concat[3].set_ylabel('Squared Loss')
axs_concat[3].set_xlabel('Iteration')
axs_concat[3].legend()
axs_concat[3].set_title('Loss Evolution')

# Ajustar y mostrar todo
fig_concat.tight_layout()
plt.show()

# Si deseas guardar el gr谩fico completo concatenado
# fig_concat.savefig('combined_graphics.png', dpi=300)

"""En el gr谩fico de Loss v/s iteraciones se pude observar a simple vista un mejor comportamiento de KAN sobre MLP para las primeras iteraciones, ya que la curva de loss de KAN est谩 por debajo de la de KAN para el primer rango de iteraciones. Sin embargo, se puede observar que la convergencia del valor de LOSS para MLP se alcanz贸 con mayor velocidad que para KAN, por lo que se puede entender que, a partir de cierta cantidad de iteraciones MLP funciona mucho mejor para datos con este tipo de distribuci贸n.

A煤n as铆, KAN se adapt贸 adecuadamente a la relaci贸n lineal. La salida es consistente con lo esperado y el valor de LOSS es considerablemente bajo y aceptable.

Al igual que para el ejemplo 1, MLP obtuvo mejor rendimiento sobre datos con distribuci贸n lineal que KAN, mientras que KAN tiene mejor rendimiento sobre datos con distribuci贸n compleja que MLP.

### Ejemplo 3

Para este apartado se realiza el ejemplo de clasificaci贸n con datos generados (primero con una relaci贸n entre los datos compleja y luego una lineal) y se compara el resultado obtenido en KAN-MLP y tambi茅n con el resultado obtenido en el ejemplo 3 de clasificaci贸n del tutorial.

A continuaci贸n se generaron datos de entrenamiento con una distribuci贸n compleja, espec铆ficamente c铆rculos conc茅ntricos con un nivel moderado de ruido, para evaluar la capacidad de dos modelos (KAN y MLP) en resolver problemas de clasificaci贸n no lineal. La idea es que los modelos identifiquen los dos grupos generados, donde cada uno pertenece a distintas regiones de los circulos coc茅ntricos.
Ambos modelos fueron entrenados utilizando estos datos y se generaron gr谩ficos para analizar su desempe帽o: Los datos generados sobre el plano $(x,y)$, las predicciones realizadas por cada modelo (KAN y MLP) destacando las regiones clasificadas seg煤n las probabilidades asignadas, y la evoluci贸n de la p茅rdida (loss) durante el proceso de entrenamiento. Estos resultados permiten comparar visualmente c贸mo cada modelo ajusta su capacidad de clasificaci贸n a una estructura m谩s compleja y c贸mo evolucionan hacia la convergencia durante el entrenamiento.
"""

# @title Ejemplo de clasificaci贸n con datos con distribuci贸n compleja.

import numpy as np
import matplotlib.pyplot as plt
from sklearn import datasets

# Definici贸n de la funci贸n softmax
def softmax(z):
    e_z = np.exp(z - np.max(z))  # Estabilidad num茅rica
    return e_z / e_z.sum(axis=-1, keepdims=True)

# Crear nuevos datos con una forma diferente (c铆rculos)
n_samples = 100
noise = 0.12
x_train_cl, y_train_cl = datasets.make_circles(n_samples=n_samples, noise=noise, factor=0.5)

# Normalizar entre -1 y 1
x_train_cl[:, 0] = (x_train_cl[:, 0] - min(x_train_cl[:, 0])) / max(x_train_cl[:, 0] - min(x_train_cl[:, 0])) * 2 - 1
x_train_cl[:, 1] = (x_train_cl[:, 1] - min(x_train_cl[:, 1])) / max(x_train_cl[:, 1] - min(x_train_cl[:, 1])) * 2 - 1

# Par谩metros
n_iter_train_cl = int(1e3)
loss_tol_cl = 0.01
seed = 476

# Crear la malla de puntos de prueba en el rango [-1, 1]
X1_cl, X2_cl = np.meshgrid(np.linspace(-1, 1, 40), np.linspace(-1, 1, 50))
x_cl = np.concatenate((X1_cl.reshape(-1, 1), X2_cl.reshape(-1, 1)), axis=1)

# MLP
mlp_cl = FeedForward([2, 5, 2],  # layer size
                     eps=.01,  # gradient descend parameter
                     activation=relu,  # activation type (relu, tanh_act or sigmoid_act)
                     neuron_class=NeuronNN,
                     loss=CrossEntropyLoss,
                     seed=seed,
                     weights_range=[-0.5, 0.5])
mlp_cl.train(x_train_cl,
             y_train_cl.reshape(-1, 1),
             n_iter_max=n_iter_train_cl,
             loss_tol=loss_tol_cl)

# KAN
kan_cl = FeedForward([2, 2],  # layer size
                     eps=.01,  # gradient descent parameter
                     n_weights_per_edge=8,  # n. edge functions
                     neuron_class=NeuronKAN,
                     loss=CrossEntropyLoss,
                     x_bounds=[-1, 1],  # input domain bounds
                     get_edge_fun=get_bsplines,  # edge function type (B-splines or Chebyshev)
                     seed=seed,
                     weights_range=[-0.5, 0.5])
kan_cl.train(x_train_cl,
             y_train_cl.reshape(-1, 1),
             n_iter_max=n_iter_train_cl,
             loss_tol=loss_tol_cl)

# Paso 1: Visualizar datos de entrenamiento
fig_concat, axs_concat = plt.subplots(1, 4, figsize=(18, 4))

# Datos de entrenamiento (c铆rculos conc茅ntricos)
axs_concat[0].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
axs_concat[0].set_xlabel('Input feature 1')
axs_concat[0].set_ylabel('Input feature 2')
axs_concat[0].set_title('Training Data')
axs_concat[0].set_aspect('equal')
axs_concat[0].grid()

# Clasificaci贸n KAN
Y_kan_cl = np.array([softmax(kan_cl(x))[1] for x in x_cl]).reshape(X1_cl.shape)
im0 = axs_concat[1].pcolor(X1_cl, X2_cl, Y_kan_cl, vmin=0, vmax=1, cmap=plt.cm.bwr)
axs_concat[1].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
axs_concat[1].set_xlabel('Input feature 1')
axs_concat[1].set_ylabel('Input feature 2')
axs_concat[1].set_title('KAN Classification')
axs_concat[1].set_aspect('equal')
fig_concat.colorbar(im0, ax=axs_concat[1])

# Clasificaci贸n MLP
Y_mlp_cl = np.array([softmax(mlp_cl(x))[1] for x in x_cl]).reshape(X1_cl.shape)
im1 = axs_concat[2].pcolor(X1_cl, X2_cl, Y_mlp_cl, vmin=0, vmax=1, cmap=plt.cm.bwr)
axs_concat[2].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
axs_concat[2].set_xlabel('Input feature 1')
axs_concat[2].set_ylabel('Input feature 2')
axs_concat[2].set_title('MLP Classification')
axs_concat[2].set_aspect('equal')
fig_concat.colorbar(im1, ax=axs_concat[2])

# Evoluci贸n de la p茅rdida
axs_concat[3].plot(kan_cl.loss_hist, label='KAN', color='blue')
axs_concat[3].plot(mlp_cl.loss_hist, label='MLP', color='orange')
axs_concat[3].plot(loss_tol_cl * np.ones(max(len(mlp_cl.loss_hist), len(kan_cl.loss_hist))), '--k')
axs_concat[3].set_xlabel('Iteration')
axs_concat[3].set_ylabel('Loss')
axs_concat[3].set_title('Loss Evolution')
axs_concat[3].legend()
axs_concat[3].grid()

# Ajustar y mostrar
fig_concat.tight_layout()
plt.show()

# Guardar el gr谩fico completo concatenado si es necesario
# fig_concat.savefig('combined_classification_results.png', dpi=300)

"""De los resultados se obtiene el comportamiento esperado, donde KAN obtiene una mejor respuesta ante la distribuci贸n dada de los datos. Al observar la gr谩fica de Loss v/s Iteraciones, se observa que KAN tiene menor p茅rdida ante MLP para este problema. Esto se debe a la mejor representaci贸n de los datos por parte de KAN, el cual en base a funciones de activaci贸n spline se obtiene una mayor flexibilidad y suavidad en las curvas generadas. Esto permite manejar problemas complejos y no lineales, como se observa en la figura redonda de la regi贸n.

MLP logra distinguir la clase del grupo azul, pero la clase del grupo rojo se representa por un 谩rea blanca, lo que indica que el modelo tiene baja confianza para clasificar los datos de tal clase, y adem谩s se genera una regi贸n de decisi贸n que tiene bordes r铆gidos y angulares. Esto, y los valores de LOSS altos, refuerza la idea de que MLP no representa precisamente datos con una distribuci贸n compleja.

A continuaci贸n se presenta el ejemplo 3 realizado por el tutorial, que aborda un problema muy similar pero ante una distribuci贸n distinta de los datos.

![image.png](data:image/png;base64,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C5NKuNjlFrWbM2cO2RGB1sxNcN1CdWr3888/41G466+/vkGDBqQJgpzKtTxz586VJMlqtXJ1EJket4Cgdh43qU8rxNSO9ltTPb7++uv+/fvHxMQowYsM/QMApnazZs2i5xIomT59OslhXCtJkkaPHq0snJycPHz4cAAgL/9jjz2m/HXSpEnOqB0ZUnv33XeV5dPT05XUbvXq1R06dAgNDaUX0qxZM1KeS+1+//33CRMmxMXF0fKSJD3++OPKJkRaWEBYgGsB4jatWbOmfv36DRs2/Oabb5hib775piRJmzZtOvzn36233pqUlEQ7ianjBQDKgTuVUbuNGzdKkrRr1y6mLXLI4M+ePXt69uxJ9nSi7zjpFK+srLz55purRtViYmJKSkpWrlxJ5yn8+uuvbdu2rYosl5SUdNdddyk5HuOZqVO7Nm3a4KCgVO3XX389MzPTYrFQxUwmE/1Vndo99dRTkiR9//33tHzVkum0tLSuXbuSnPz8/DZt2ih/HTZsWEpKijJHpIUFAt4CSoTp3bt3//79V69ebTabyZi/W9SuKsbvrl273nnnnT179vz666/OTHfixAlJkh5++GFuAQZA/ve//w0bNqxu3boUBCRJWrNmDTl33rx5QUFBoaGhVZERnn766V9++YXkq2CXW9Ru9OjRQUFBzjr61d1CdWr30UcfSZL04osvKo0wceLEqsU+58+fr8okyKmM1k7u1E8//aQ8RaS9ZwFB7bxnW1/UjKkd0x1+5syZ+vXrN2vWbP78+a+//vquXbuefvpp5ba8mNoxkwTo3O6q62FcK7xRTHJyMokK4HFqt27duqrBxv79+69du3bHjh27du0qLCyk8Xm51K5nz57h4eGPPfbY5s2bd+7cuWPHDuW1+OL2iDaEBfzWAtRt+vjjj6Oiopo0aXLkyBHl1QwZMkTpstA0jW9EayBnDR8+nAzceYTafffddxaLpVOnTsuWLXvzzTd37dpFeo7oeg8A+Oijjx566KEuXbpUxZFr3779uXPniCalpaXbtm0bM2ZMSkqKJEl0HhHjmemmdh988IHJZMrPz3/xxRe3b9++a9cuYitqvepTOwbnlTBOWxEJYYHAtoASYdauXWuxWLp3706H1NyidswL5cxu2qldeXl5q1atGjRoMGvWrK1bt+7atWv16tXMrt/ffffdM888c91115nN5tjY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)

Ambos ejemplos de clasificaci贸n de datos con una distribuci贸n no lineal, teniendo mejor desempe帽o para KAN. Esto refuerza una vez m谩s que KAN captura mejor las relaciones no lineales. A煤n as铆, para este ejemplo MLP si logr贸 adaptarse adecuadamente a la distribuci贸n de los datos a pesar de no tener una distribuci贸n lineal. Esto se debe principalmente a los distintos par谩metros utilizados, ya que se usaron distintas funciones de activaci贸n (Tangente hiperb贸lica para el ejemplo del tutorial y ReLU para el ejemplo generado con los circulos coc茅ntricos) adem谩s de la cantidad de capas y neuronas en la red.

En el siguiente bloque de c贸digo se busca realizar un ejemplo para clasificaci贸n con una distribuci贸n lineal de los datos con el fin de observar el comportamiento de ambos modelos. Se generan dos grupos de datos que son linealmente separables en el espacio. Se entrenan con ambos modelos y se comparan posteriormente.
"""

# @title Ejemplo con datos con una distribuci贸n lineal para clasificaci贸n.
import numpy as np
import matplotlib.pyplot as plt

# Generar datos replicando la distribuci贸n de la imagen
def generate_refined_data(n_samples, noise_level=0.05, seed=42):
    """
    Genera un problema de clasificaci贸n con puntos azules concentrados,
    pero con algunos dispersos alrededor.

    Parameters:
        - n_samples: Total de puntos (se dividir谩 entre las dos clases).
        - noise_level: Nivel de ruido para simular variabilidad real.
        - seed: Semilla para reproducibilidad.

    Returns:
        - X: Array de caracter铆sticas (n_samples, 2).
        - y: Etiquetas de clase (0 o 1).
    """
    np.random.seed(seed)

    # Dividir el n煤mero de muestras entre las dos clases
    n_blue = n_samples // 2
    n_red = n_samples - n_blue

    # Generar puntos azules (concentrados en un centro)
    center_x1 = np.random.uniform(-0.5, 0.5, int(0.8 * n_blue))  # 80% en el centro
    center_x2 = np.random.uniform(-0.8, -0.2, int(0.8 * n_blue))  # M谩s concentrados
    outer_x1 = np.random.uniform(-1, 1, int(0.2 * n_blue))  # 20% m谩s dispersos
    outer_x2 = np.random.uniform(-1, 0, int(0.2 * n_blue))  # M谩s alejados

    x1_blue = np.concatenate((center_x1, outer_x1))
    x2_blue = np.concatenate((center_x2, outer_x2))

    # Generar puntos rojos (distribuidos cerca de la l铆nea divisoria)
    x1_red = np.random.uniform(-0.5, 1, n_red)
    x2_red = -x1_red + 0.5 + np.random.normal(0, noise_level, n_red)  # Alrededor de la l铆nea

    # Etiquetas
    y_blue = np.zeros(n_blue, dtype=int)
    y_red = np.ones(n_red, dtype=int)

    # Unir datos
    X_blue = np.vstack((x1_blue, x2_blue)).T
    X_red = np.vstack((x1_red, x2_red)).T
    X = np.vstack((X_blue, X_red))
    y = np.concatenate((y_blue, y_red))

    return X, y

# Generar datos
n_samples = 200
noise_level = 0.03
x_train_cl, y_train_cl = generate_refined_data(n_samples, noise_level=noise_level)

# Par谩metros de entrenamiento
n_iter_train_cl = int(500)
loss_tol_cl = 0.01
seed = 42

# MLP
mlp_cl = FeedForward(
    [2, 3, 2],
    eps=0.02,
    activation=tanh_act,
    neuron_class=NeuronNN,
    loss=CrossEntropyLoss,
    seed=seed,
    weights_range=[-0.5, 0.5]
)

mlp_cl.train(x_train_cl, y_train_cl.reshape(-1, 1), n_iter_max=n_iter_train_cl, loss_tol=loss_tol_cl)

# KAN
kan_cl = FeedForward(
    [2, 2],  # Tama帽o de las capas
    eps=0.01,  # Gradiente descendente
    n_weights_per_edge=8,  # N煤mero de funciones de borde
    neuron_class=NeuronKAN,
    loss=CrossEntropyLoss,
    x_bounds=[-1, 1],  # L铆mites de entrada
    get_edge_fun=get_bsplines,
    seed=seed,
    weights_range=[-0.5, 0.5]
)

kan_cl.train(x_train_cl, y_train_cl.reshape(-1, 1), n_iter_max=n_iter_train_cl, loss_tol=loss_tol_cl)

# Crear malla para evaluar modelos
X1_cl, X2_cl = np.meshgrid(np.linspace(-1.5, 1.5, 100), np.linspace(-1.5, 1.5, 100))
x_cl = np.concatenate((X1_cl.reshape(-1, 1), X2_cl.reshape(-1, 1)), axis=1)

# Predicciones para visualizaci贸n
def softmax(vec):
    exp_vec = np.exp(vec - np.max(vec))
    return exp_vec / np.sum(exp_vec)

Y_kan_cl = np.array([softmax(kan_cl(x))[1] for x in x_cl]).reshape(X1_cl.shape)
Y_mlp_cl = np.array([softmax(mlp_cl(x))[1] for x in x_cl]).reshape(X1_cl.shape)

# Graficar los resultados en una fila
fig, ax = plt.subplots(1, 4, figsize=(18, 4))

# Datos originales
ax[0].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr, edgecolor="k")
ax[0].axline((0, 0.5), slope=-1, color="black", linestyle="--", label="Separaci贸n real")
ax[0].set_title("Training Data")
ax[0].legend()
ax[0].set_xlabel("Feature 1")
ax[0].set_ylabel("Feature 2")
ax[0].grid()

# Clasificaci贸n KAN
im0 = ax[1].pcolor(X1_cl, X2_cl, Y_kan_cl, cmap=plt.cm.bwr, shading='auto', vmin=0, vmax=1)
ax[1].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr, edgecolor="k")
ax[1].set_title("KAN Classification")
fig.colorbar(im0, ax=ax[1])
ax[1].set_xlabel("Feature 1")
ax[1].set_ylabel("Feature 2")

# Clasificaci贸n MLP
im1 = ax[2].pcolor(X1_cl, X2_cl, Y_mlp_cl, cmap=plt.cm.bwr, shading='auto', vmin=0, vmax=1)
ax[2].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr, edgecolor="k")
ax[2].set_title("MLP Classification")
fig.colorbar(im1, ax=ax[2])
ax[2].set_xlabel("Feature 1")
ax[2].set_ylabel("Feature 2")

# P茅rdida vs Iteraciones
ax[3].plot(kan_cl.loss_hist, label='KAN Loss', color='blue', linewidth=2)
ax[3].plot(mlp_cl.loss_hist, label='MLP Loss', color='orange', linewidth=2)
ax[3].axhline(y=loss_tol_cl, color='black', linestyle='--', label='Loss Tolerance')
ax[3].set_title("Loss vs Iterations")
ax[3].set_xlabel("Iterations")
ax[3].set_ylabel("Loss")
ax[3].legend()
ax[3].grid()

plt.tight_layout()
plt.show()

"""Aqu铆 se puede observar un mejor comportamiento para MLP que para KAN en este problema que se dise帽贸 para que la regi贸n de clasificaci贸n sea lineal y no compleja. En el gr谩fico de Loss v/s Iterations se puede observar una mayor precisi贸n para MLP que para KAN, pero de igual manera pasado cierto rango de iteraciones, el modelo KAN logra entender la relaci贸n esperada para este modelo pero con menor velocidad que MLP.
Ambos modelos lograron capturar una regi贸n de clasificac贸n adecuada.

Al comparar los tres ejercicios presentes de clasificaci贸n se entiende que KAN tiene mejor comportamiento al clasificar datos con una relaci贸n de distribuci贸n compleja, a diferencia de MLP que tiene mayor precisi贸n al clasificar datos que se distribuyen de manera lineal.

###**Discusi贸n General**
En relaci贸n con el primer ejercicio, el modelo KAN sobresale por su capacidad para abordar problemas de clasificaci贸n con relaciones no lineales complejas. Este desempe帽o subraya su potencial en aplicaciones donde los datos presentan patrones dif铆ciles de separar con modelos lineales o arquitecturas menos flexibles.

En el segundo ejercicio, al igual que en el primero, KAN se destaca como la opci贸n m谩s eficaz. Su habilidad para representar distribuciones no lineales altamente complejas, como las estructuras conc茅ntricas, demuestra su superioridad frente al modelo MLP. Mientras que KAN consigue capturar estas geometr铆as de manera precisa, la MLP presenta limitaciones evidentes al enfrentarse a datos de este tipo, mostrando una menor capacidad de adaptaci贸n a patrones complejos.

##Item 3. An谩lisis y Explicaci贸n de la Arquitectura

La arquitectura **Kolmogorov-Arnold Networks** (*KAN*) se basa en el teorema de Kolmogorov-Arnold, que asegura que **cualquier funci贸n continua de m煤ltiples variables puede descomponerse en una suma de funciones univariables compuestas**. Este principio permite construir redes neuronales capaces de aproximar cualquier funci贸n con alta precisi贸n, aprovechando una combinaci贸n de transformaciones no lineales y estructuras diferenciables.

### Construcci贸n de la Arquitectura
La implementaci贸n de la arquitectura KAN incluye los siguientes elementos principales:

1. ***Neuronas KAN (NeuronKAN):*** Estas neuronas ampl铆an el concepto b谩sico de una neurona tradicional al incorporar funciones llamadas **funciones de borde (edge functions)**. Las funciones de borde, como los *B-splines*, transforman las entradas de manera no lineal antes de ser ponderadas por los pesos y combinadas en la salida intermedia (xmid). Finalmente, la salida intermedia pasa por una funci贸n de activaci贸n, como tanh, para generar la salida final (xout).

2. ***Funciones de borde (B-splines):*** Son funciones diferenciables que segmentan el espacio de entrada en regiones, permitiendo una representaci贸n flexible de relaciones no lineales. Estas funciones se ajustan autom谩ticamente durante el entrenamiento para optimizar la capacidad de modelado de las neuronas.

3. ***Capas completamente conectadas:*** Una capa consiste en un conjunto de NeuronKAN conectadas a trav茅s de pesos. Esta estructura permite transformar las entradas en representaciones m谩s abstractas en las siguientes capas.

4. ***C谩lculo de p茅rdida y retropropagaci贸n:*** La **p茅rdida** se calcula usando m茅tricas como el error cuadr谩tico medio (SquaredLoss) o entrop铆a cruzada (CrossEntropyLoss). La **retropropagaci贸n** se encarga de actualizar los pesos a trav茅s del c谩lculo de gradientes, utilizando las derivadas exactas de las funciones de borde y de activaci贸n.

5. ***Proceso de entrenamiento:*** El modelo se entrena mediante el m茅todo de descenso de gradiente, optimizando los pesos de cada capa para minimizar la p茅rdida global en un conjunto de datos.

### Funcionamiento de KAN
El flujo de trabajo de una KAN incluye dos fases principales:

1. ***Transformaci贸n de entrada (Funciones de borde):*** Cada entrada pasa por una transformaci贸n no lineal usando funciones de borde, como los B-splines. Estas funciones segmentan el espacio de entrada y permiten una representaci贸n flexible de las relaciones entre las variables.

2. ***Ponderaci贸n y combinaci贸n:*** Las salidas de las funciones de borde son ponderadas por un conjunto de pesos asociados. Estas combinaciones ponderadas generan una salida intermedia (xmid) en cada neurona.

3. ***Funci贸n de activaci贸n:*** La salida intermedia es procesada por una funci贸n de activaci贸n (e.g., tanh), que introduce no linealidad en el modelo y permite manejar relaciones complejas entre las variables.

4. ***C谩lculo de la salida final:*** La salida de cada capa pasa a la siguiente, continuando el procesamiento hasta obtener la salida final de la red. Este flujo permite transformar las entradas originales en representaciones cada vez m谩s abstractas.

5. ***Retropropagaci贸n y aprendizaje:*** Durante el entrenamiento, el modelo calcula la diferencia entre las predicciones y las etiquetas reales (funci贸n de p茅rdida). Los gradientes se calculan y propagan hacia atr谩s, ajustando los pesos de cada neurona para minimizar la p茅rdida.

Las redes de Kolmogorov-Arnold (KAN) se han mostrado prometedoras en diversos campos debido a su capacidad para modelar relaciones complejas y no lineales con menos par谩metros que las redes neuronales tradicionales. He aqu铆 algunos casos de uso clave:
- **Modelizaci贸n cient铆fica y ajuste de datos**
- **Resoluci贸n de ecuaciones diferenciales parciales (EDP)**
- **Regresi贸n simb贸lica**

### Ventajas y Desventajas de las KAN
Las ventajas que posee esta arquitectura, mejoran las limitaciones de las redes convencionales:
- ***Interpretabilidad***: A diferencia de los modelos tradicionales de aprendizaje profundo, los KAN proporcionan una estructura m谩s interpretable. Las funciones aprendibles pueden visualizarse y analizarse, ofreciendo informaci贸n sobre el proceso de toma de decisiones del modelo. Esta caracter铆stica es especialmente valiosa en los campos cient铆ficos, donde comprender el funcionamiento del modelo es tan crucial como lograr una gran precisi贸n.
- ***Flexibilidad***: Las KAN no se limitan a un 煤nico tipo de funci贸n de activaci贸n. Aunque suelen utilizar B-splines, pueden emplearse otras funciones de base, como los polinomios de Chebyshev, en funci贸n de la tarea espec铆fica. Esta flexibilidad hace que la arquitectura sea vers谩til y adaptable a diversas aplicaciones.

Pero como cualquier tecnologia, vienen sus propias debilidades como:
- ***Complejidad computacional***: Uno de los retos de las KAN es su intensidad computacional durante la fase de entrenamiento. Como los KAN utilizan funciones de activaci贸n aprendibles en los bordes, la complejidad de la evaluaci贸n de estas funciones puede ralentizar considerablemente el proceso de entrenamiento en comparaci贸n con los MLP tradicionales. Esta complejidad se amplifica a煤n m谩s en tareas que requieren arquitecturas KAN profundas o funciones base muy detalladas.
-***Necesidad de experiencia***: Implementar y ajustar las KAN puede ser m谩s complejo que trabajar con MLP tradicionales. La selecci贸n de las funciones de base adecuadas (por ejemplo, B-splines, polinomios de Chebyshev) y la configuraci贸n del modelo para una tarea espec铆fica requieren una comprensi贸n matem谩tica m谩s profunda y una mayor interacci贸n entre el ser humano y el modelo. Esto puede hacer que las KAN sean menos accesibles para los profesionales sin conocimientos especializados.

### Analisis Detallados de los Resultados Obtenidos

#### Ejemplo 1: Regresi贸n con Distribuci贸n Compleja y Lineal

KAN mostr贸 una representaci贸n m谩s precisa de los datos gracias a su capacidad de modelar relaciones no lineales utilizando funciones borde (b-spline).

Por otro lado, en las distribuciones lineales, MLP super贸 a KAN, mostrando una representaci贸n m谩s precisa de la tendencia lineal de los datos.

Se destacan las ventajas de KAN en distribuciones complejas, KAN demostr贸 mayor capacidad de representaci贸n debido a su flexibilidad y su habilidad para detectar comportamientos no lineales. Su convergencia m谩s r谩pida para datos complejos reafirma su efectividad en escenarios donde la relaci贸n entre las variables no es trivial.

Mientras que sus limitaciones, demostro desventajas, principalmente debido a su tendencia a agregar patrones innecesarios que complicaron la representaci贸n de los datos.

#### Ejemplo 2: Regresi贸n 2D

Para el ejemplo lineal KAN demostr贸 un mejor comportamiento durante las primeras iteraciones. Esto se reflej贸 en la curva de p茅rdida, donde KAN mostr贸 valores m谩s bajos que MLP en el rango inicial. Sin embargo, a medida que avanzaron las iteraciones, MLP alcanz贸 la convergencia del valor de p茅rdida con mayor rapidez, logrando representar los datos lineales de forma precisa. Aunque KAN logr贸 adaptarse adecuadamente a esta distribuci贸n, su mayor complejidad introdujo patrones innecesarios, resultando en un proceso de convergencia m谩s lento.

Este ejemplo reafirma que KAN y MLP tienen puntos fuertes en diferentes contextos. KAN es m谩s eficiente para datos con relaciones complejas y no lineales, mientras que MLP sobresale en escenarios donde los datos presentan distribuciones lineales claras. La elecci贸n entre ambos modelos debe estar guiada por la naturaleza de los datos a procesar y los objetivos del an谩lisis.

#### Ejemplo 3: Clasificaci贸n con Datos Complejos

Una vez m谩s los resultados confirman que **KAN supera a MLP en el escenario complejo**, logrando una mejor representaci贸n de los datos gracias a la flexibilidad de sus funciones spline. La gr谩fica de Loss v/s Iteraciones refuerza esta conclusi贸n, mostrando que KAN alcanz贸 valores de p茅rdida m谩s bajos que MLP a lo largo del entrenamiento.

MLP logr贸 clasificar correctamente una de las clases para el ejemplo con datos distribuidos linealmente, pero present贸 baja confianza en el problema complejo. Adem谩s, los bordes de decisi贸n de MLP fueron r铆gidos y angulares, lo que refleja su **limitada capacidad para adaptarse a relaciones no lineales complejas**.

Se entiende con esto que ***KAN sobresale en problemas de clasificaci贸n con distribuciones complejas, mientras que MLP es m谩s adecuado para clasificaciones lineales.*** Este comportamiento se alinea con lo observado en los ejercicios de regresi贸n de los ejemplos anteriores. En particular, los resultados destacan c贸mo las propiedades de las funciones de activaci贸n (tangente hiperb贸lica en el tutorial y ReLU en el ejercicio de c铆rculos conc茅ntricos) influyen en la capacidad de los modelos para adaptarse a diferentes patrones.

En relaci贸n con los t*res ejercicios de clasificaci贸n*, se confirma que **KAN es la opci贸n m谩s eficaz para datos con relaciones complejas**, como estructuras conc茅ntricas, **gracias a su capacidad de capturar patrones no lineales con mayor precisi贸n**. Por otro lado, **MLP tiene un desempe帽o superior al enfrentar datos linealmente separables**, mostrando mayor rapidez y precisi贸n en su convergencia.

En resumen, ***la elecci贸n del modelo debe basarse en la naturaleza de los datos y los requisitos del problema***, destacando la **flexibilidad de KAN y la eficiencia de MLP en sus respectivos dominios.**
"""