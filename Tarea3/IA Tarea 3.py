# -*- coding: utf-8 -*-
"""IA_Tarea_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zhlMMQgQt6IEJFAn8dQAVc-wDic3E4k0

# Tarea 3 de Inteligencia Artificial - Diego Pastrian & Ignacio Medina

En este documento se explora un enfoque dentro del campo de las redes neuronales artificiales (ANN): las ***Kolmogorov-Arnold Networks (KAN)***. El principal objetivo es implementar esta arquitectura siguiendo el tutorial presente en la página [A from scratch implementation of kolmogorov arnold networks (KAN).](https://mlwithouttears.com/2024/05/15/a-from-scratch-implementation-of-kolmogorov-arnold-networks-kan/).

## Item 1. Implementación del Tutorial.

### Implementación.
La primera actividad a realizar es la implementación del algoritmo KAN.

*   El input de la neurona ***xin*** se representa por $\mathbf{x}^{\text{in}} = [x^{\text{in}}_1, \dots, x^{\text{in}}_M]$, donde las neuronas tienen ***n_in*** inputs los cuales a través de la neurona sufrirán una transformación intermedia $\phi(x^{\text{in}}_i,w^i)$.

*   De lo anterior, $x^{\text{mid}}_i = \phi(x^{\text{in}}_i, \mathbf{w}^i)$ representa a la salida intermedia en la neurona (***xmid*** en código). $\mathbf{w}^i = [w^i_1, \dots, w^i_K]$ son los pesos ***weights***, estos indican la importancia de la conexión entre una neurona y otra. Los pesos se inicializan con valores aleatorios entre -1 y 1.

*   El sesgo $b$, representado en el código por ***bias*** sirve para ajustar el resultado obtenido. Se inicializa en 0 y se ajusta con el entrenamiento del modelo.

*   Se tiene una salida ***xout***, que sería el resultado de salida de la neurona.

*   Desde la salida de la red hacia las capas anteriores (retropropagación) se reajustan los pesos $W^i$ y el sesgo $b$ minimizando la pérdida $\mathcal{L}$ (Que mide la diferencia entre las predicciones del modelo y los valores reales) con el método del gradiente descendiente. Para esto:
      *  Se utiliza la regla de la cadena para descomponer las derivadas en partes manejables en una neurona individual.
      \$[
\frac{\partial \mathcal{L}}{\partial b} = \frac{\partial \mathcal{L}}{\partial x^{\text{out}}} \cdot \frac{\partial x^{\text{out}}}{\partial b}.
\$]
\$[
\frac{\partial \mathcal{L}}{\partial w^i_j} = \frac{\partial \mathcal{L}}{\partial x^{\text{out}}} \cdot \frac{\partial x^{\text{out}}}{\partial w^i_j}, \quad \forall i, j.
\$]
      *   De lo anterior, se puede calcular $\( \frac{\partial x^{\text{out}}}{\partial b} \)$ y $\( \frac{\partial x^{\text{out}}}{\partial w^i_j} \)$ con las variables internas a la neurona.
"""

import numpy as np

class Neuron:

    def __init__(self, n_in, n_weights_per_edge, weights_range=None):
        self.n_in = n_in  # n. inputs
        self.n_weights_per_edge = n_weights_per_edge
        weights_range = [-1, 1] if weights_range is None else weights_range
        self.weights = np.random.uniform(weights_range[0], weights_range[-1], size=(self.n_in, self.n_weights_per_edge))
        self.bias = 0
        self.xin = None  # input variable
        self.xmid = None  # edge variables
        self.xout = None  # output variable
        self.dxout_dxmid = None  # derivative d xout / d xmid: (n_in, )
        self.dxout_dbias = None  # derivative d xout / d bias
        self.dxmid_dw = None  # derivative d xmid / d w: (n_in, n_par_per_edge)
        self.dxmid_dxin = None  # derivative d xmid / d xin
        self.dxout_dxin = None  # (composite) derivative d xout / d xin
        self.dxout_dw = None  # (composite) derivative d xout / d w
        self.dloss_dw = np.zeros((self.n_in, self.n_weights_per_edge))  # (composite) derivative d loss / d w
        self.dloss_dbias = 0  # (composite) derivative d loss / d bias

    def __call__(self, xin):
        # forward pass: compute neuron's output
        self.xin = np.array(xin)
        self.get_xmid()
        self.get_xout()

        # compute internal derivatives
        self.get_dxout_dxmid()
        self.get_dxout_dbias()
        self.get_dxmid_dw()
        self.get_dxmid_dxin()

        assert self.dxout_dxmid.shape == (self.n_in, )
        assert self.dxmid_dxin.shape == (self.n_in, )
        assert self.dxmid_dw.shape == (self.n_in, self.n_weights_per_edge)

        # compute external derivatives
        self.get_dxout_dxin()
        self.get_dxout_dw()

        return self.xout

    def get_xmid(self):
        # compute self.xmid
        pass

    def get_xout(self):
        # compute self.xout
        pass

    def get_dxout_dxmid(self):
        # compute self.dxout_dxmid
        pass

    def get_dxout_dbias(self):
        # compute self.dxout_dbias
        pass  #self.dxout_dbias = 0  # by default

    def get_dxmid_dw(self):
        # compute self.dxmid_dw
        pass

    def get_dxmid_dxin(self):
        # compute self.dxmid_dxin
        pass

    def get_dxout_dxin(self):
        self.dxout_dxin = self.dxout_dxmid * self.dxmid_dxin

    def get_dxout_dw(self):
        self.dxout_dw = np.diag(self.dxout_dxmid) @ self.dxmid_dw

    def update_dloss_dw_dbias(self, dloss_dxout):
        self.dloss_dw += self.dxout_dw * dloss_dxout
        self.dloss_dbias += self.dxout_dbias * dloss_dxout

    def gradient_descent(self, eps):
        self.weights -= eps * self.dloss_dw
        self.bias -= eps * self.dloss_dbias

"""

La función de activación $\sigma$ puede estar dada por las funciones:


*   ***relu*** : Función ReLU
  $$
  \sigma(x) =
  \begin{cases}
  0, & \text{si } x \leq 0 \\
  x, & \text{si } x > 0
  \end{cases}
  $$
    

*   ***tanh_act***: Función Tangente hiperbólica $$σ(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}}$$
*   ***sigmoid_act***: Función sigmoide $$\sigma(x) = \frac{1}{1 + e^{-x}}$$

Estas funciones son esenciales para introducir no linealidad al modelo, permitiendo que la red neuronal pueda aprender relaciones complejas entre las entradas y salidas. Para KAN, estas aseguran que las transformaciones entre las capas sean flexibles para descomponer y aproximar funciones continuas.
"""

import math

def relu(x, get_derivative=False):
    return x * (x > 0) if not get_derivative else 1.0 * (x >= 0)

def tanh_act(x, get_derivative=False):
    if not get_derivative:
        return math.tanh(x)
    return 1 - math.tanh(x) ** 2

def sigmoid_act(x, get_derivative=False):
    if not get_derivative:
        return 1 / (1 + math.exp(-x))
    return sigmoid_act(x) * (1 - sigmoid_act(x))

"""A continuación se implementa la clase ***NeuronNN***, que corresponde a una neurona más general en el contexto de redes neuronales, heredando la clase ***Neuron*** para el cálculo de los valores intermedios $x^{mid}$ y finales $x^{out}$ de una neurona, además el cálculo de las derivadas auxiliares necesarias para la retropropagación.


*   Se calcula la salida intermedia ***xmid*** como el producto elemento a elemento entre las entradas ***xin*** por sus correspondientes pesos ***weight***.
*   Se calcula ***xout*** con la función de activación evaluada en las salidas intermedias y el sesgo $b$.
$ x^{\text{out}} = \sigma\left(\mathbf{x}^{\text{mid}}, b\right) := \sigma\left(b + \sum_{i=1}^M x^{\text{mid}}_i\right)$, siendo $\sigma$ la función de activación, la cual se debe definir en la inicialización.
*   Para ajustar los parámetros como el sesgo $b$ y los pesos $w$, se implementan funciones para el cálculo de las derivadas parciales de la salida $x^{out}$ con respecto a $x^{mid}$.


"""

class NeuronNN(Neuron):

    def __init__(self, n_in, weights_range=None, activation=relu):
        super().__init__(n_in, n_weights_per_edge=1, weights_range=weights_range)
        self.activation = activation
        self.activation_input = None

    def get_xmid(self):
        self.xmid = self.weights[:, 0] * self.xin

    def get_xout(self):
        self.activation_input = sum(self.xmid.flatten()) + self.bias
        self.xout = self.activation(self.activation_input, get_derivative=False)

    def get_dxout_dxmid(self):
        self.dxout_dxmid = self.activation(self.activation_input, get_derivative=True) * np.ones(self.n_in)

    def get_dxout_dbias(self):
        self.dxout_dbias = self.activation(self.activation_input, get_derivative=True)

    def get_dxmid_dw(self):
        self.dxmid_dw = np.reshape(self.xin, (-1, 1))

    def get_dxmid_dxin(self):
        self.dxmid_dxin = self.weights.flatten()

"""Lo particular de las redes Kolmogorov-Arnold es la utilización de la función de borde $\phi$. En el segmento de código posterior se define el uso de las funciones B-spline como las funciones 𝑓𝑘 en el borde, con la excepción de 𝑓1(𝑥), que se define como la función sigmoide modificada.
Las B-splines son funciones que se utilizan para representar funciones continuas de manera suave.
"""

from scipy.interpolate import BSpline

def get_bsplines(x_bounds, n_fun, degree=3, **kwargs):
    grid_len = n_fun - degree + 1
    step = (x_bounds[1] - x_bounds[0]) / (grid_len - 1)
    edge_fun, edge_fun_der = {}, {}

    # SiLU bias function
    edge_fun[0] = lambda x: x / (1 + np.exp(-x))
    edge_fun_der[0] = lambda x: (1 + np.exp(-x) + x * np.exp(-x)) / np.power((1 + np.exp(-x)), 2)

    # B-splines
    t = np.linspace(x_bounds[0] - degree * step, x_bounds[1] + degree * step, grid_len + 2 * degree)
    t[degree], t[-degree - 1] = x_bounds[0], x_bounds[1]
    for ind_spline in range(n_fun - 1):
        edge_fun[ind_spline + 1] = BSpline.basis_element(t[ind_spline:ind_spline + degree + 2], extrapolate=False)
        edge_fun_der[ind_spline + 1] = edge_fun[ind_spline + 1].derivative()
    return edge_fun, edge_fun_der

"""
Se implementa la neurona ***NeuronKAN* que hereda de la clase ***Neuron***. Esta reemplaza el sesgo $b$ por el uso de las funciones borde $f_k$ ya explicadas anteriormente.

*   La salida intermedia ***xmid*** se calcula como una combianación lineal de las transformaciones univariadas $\phi(x)$, que son las funciones borde $f_k(w)$

*   La salida ***xout*** se obtiene con la aplicación de una tangente hiperbólica como función de activación sobre la suma de las salidas intermedias. Al utilizar $𝜎:= tanh$ como función de activación, se mantiene la variable de salida entre -1 y 1. Esto facilita el ajuste de las B-splines.

*   Para ajustar los pesos $w$, se implementan las derivadas necesarias a calcular.

"""

class NeuronKAN(Neuron):

    def __init__(self, n_in, n_weights_per_edge, x_bounds, weights_range=None, get_edge_fun=get_bsplines, **kwargs):
        self.x_bounds = x_bounds
        super().__init__(n_in, n_weights_per_edge=n_weights_per_edge, weights_range=weights_range)
        self.edge_fun, self.edge_fun_der = get_edge_fun(self.x_bounds, self.n_weights_per_edge, **kwargs)

    def get_xmid(self):
        # apply edge functions
        self.phi_x_mat = np.array([self.edge_fun[b](self.xin) for b in self.edge_fun]).T
        self.phi_x_mat[np.isnan(self.phi_x_mat)] = 0
        self.xmid = (self.weights * self.phi_x_mat).sum(axis=1)

    def get_xout(self):
        # note: node function <- tanh to avoid any update of spline grids
        self.xout = tanh_act(sum(self.xmid.flatten()), get_derivative=False)

    def get_dxout_dxmid(self):
        self.dxout_dxmid = tanh_act(sum(self.xmid.flatten()), get_derivative=True) * np.ones(self.n_in)

    def get_dxmid_dw(self):
        self.dxmid_dw = self.phi_x_mat

    def get_dxmid_dxin(self):
        phi_x_der_mat = np.array([self.edge_fun_der[b](self.xin) if self.edge_fun[b](self.xin) is not None else 0
                                  for b in self.edge_fun_der]).T  # shape (n_in, n_weights_per_edge)
        phi_x_der_mat[np.isnan(phi_x_der_mat)] = 0
        self.dxmid_dxin = (self.weights * phi_x_der_mat).sum(axis=1)

    def get_dxout_dbias(self):
        # no bias in KAN!
        self.dxout_dbias = 0

"""Una capa completamente conectada es una colección de neuronas, donde cada entrada se conecta a todas las neuronas de la capa siguiente. Cada conexión tiene un peso asignado. Para esto, se utiliza la clase llamada ***FullyConnectedLayer***. Esto asegura que todas las entradas influyan en todas las salidas, creando un modelo que capture relaciones complejas en los datos.


En una capa completamente conectada, una entrada $x_i$ afecta la pérdida total a partir de múltiples caminos, pues como se explicó anteriormente, $x_i$ influye en todas las salidas $y_j$ de la capa. Esto se representa por la siguiente derivada:
$$
\frac{\partial \mathcal{L}}{\partial x_i^{\text{in}}} = \sum_{n=1}^N \frac{\partial \mathcal{L}}{\partial x_n^{\text{out}}} \cdot \frac{\partial x_n^{\text{out}}}{\partial x_i^{\text{in}}}, \quad \forall i
$$
Donde $\frac{\partial \mathcal{L}}{\partial x_i^{\text{in}}}$ representa cómo la entrada $i$ afecta sobre la pérdida total, $\frac{\partial \mathcal{L}}{\partial x_n^{\text{out}}}$ cómo cada salida $j$ afecta sobre la pérdida total y $\frac{\partial x_n^{\text{out}}}{\partial x_i^{\text{in}}}$ cómo la entrada $i$ afecta sobre cada salida $j$. Con esto, se puede actualizar el gradiente de las entradas durante el back-propagation.



"""

class FullyConnectedLayer:

    def __init__(self, n_in, n_out, neuron_class=NeuronNN, **kwargs):
        self.n_in, self.n_out = n_in, n_out
        self.neurons = [neuron_class(n_in) if (kwargs == {}) else neuron_class(n_in, **kwargs) for _ in range(n_out)]
        self.xin = None  # input, shape (n_in,)
        self.xout = None  # output, shape (n_out,)
        self.dloss_dxin = None  # d loss / d xin, shape (n_in,)
        self.zero_grad()

    def __call__(self, xin):
        # forward pass
        self.xin = xin
        self.xout = np.array([nn(self.xin) for nn in self.neurons])
        return self.xout

    def zero_grad(self, which=None):
        # reset gradients to zero
        if which is None:
            which = ['xin', 'weights', 'bias']
        for w in which:
            if w == 'xin':  # reset layer's d loss / d xin
                self.dloss_dxin = np.zeros(self.n_in)
            elif w == 'weights':  # reset d loss / dw to zero for every neuron
                for nn in self.neurons:
                    nn.dloss_dw = np.zeros((self.n_in, self.neurons[0].n_weights_per_edge))
            elif w == 'bias':  # reset d loss / db to zero for every neuron
                for nn in self.neurons:
                    nn.dloss_dbias = 0
            else:
                raise ValueError('input \'which\' value not recognized')

    def update_grad(self, dloss_dxout):
        # update gradients by chain rule
        for ii, dloss_dxout_tmp in enumerate(dloss_dxout):
            # update layer's d loss / d xin via chain rule
            # note: account for all possible xin -> xout -> loss paths!
            self.dloss_dxin += self.neurons[ii].dxout_dxin * dloss_dxout_tmp
            # update neuron's d loss / dw and d loss / d bias
            self.neurons[ii].update_dloss_dw_dbias(dloss_dxout_tmp)
        return self.dloss_dxin

"""Sea ***y*** la salida de la última capa, es necesario calcular la pérdida para evaluar qué tan cerca está la predicción realizada respecto a las etiquetas reales $y^{train}$.

*   Para regresión se tiene la clase ***SquaredLosss***, que busca la pérdida se calcula mediante la diferencia cuadrática, midiendo distancia entre predicciones y valores reales.
*   Para clasificación se tiene la clase ***CrossEntropyLoss***, que utiliza la pérdida de entropía cruzada. Esto mide qué tan bien la red identifica la categoría correcta. Con esto, se busca que la probabilidad asociada a la clase correcta sea la más alta, utilizando el softmax en las salidas de la red.

La idea del cálculo de este error es ajustar los parametros de la red durante su entrenamiento.


"""

class Loss:

    def __init__(self, n_in):
        self.n_in = n_in
        self.y, self.dloss_dy, self.loss, self.y_train = None, None, None, None

    def __call__(self, y, y_train):
        # y: output of network
        # y_train: ground truth
        self.y, self.y_train = np.array(y), y_train
        self.get_loss()
        self.get_dloss_dy()
        return self.loss

    def get_loss(self):
        # compute loss l(y, y_train)
        pass

    def get_dloss_dy(self):
        # compute gradient of loss wrt y
        pass


class SquaredLoss(Loss):

    def get_loss(self):
        # compute loss l(xin, y)
        self.loss = np.mean(np.power(self.y - self.y_train, 2))

    def get_dloss_dy(self):
        # compute gradient of loss wrt xin
        self.dloss_dy = 2 * (self.y - self.y_train) / self.n_in


class CrossEntropyLoss(Loss):

    def get_loss(self):
        # compute loss l(xin, y)
        self.loss = - np.log(np.exp(self.y[self.y_train[0]]) / sum(np.exp(self.y)))

    def get_dloss_dy(self):
        # compute gradient of loss wrt xin
        self.dloss_dy = np.exp(self.y) / sum(np.exp(self.y))
        self.dloss_dy[self.y_train] -= 1

"""Finalmente, se finaliza apilando una cantidad arbitraria de capas para formar una red de propagación completamente conectada.

La clase ***FeedForward*** implementa una red neuronal de tipo feed-forward completamente conectada, permitiendo realizar el entrenamiento mediante pasos de propagación hacia adelante y retropropagación.


*   En la propagación hacia adelante, los datos de entrenamiento $x^{train}$ pasan a través de las capas de la red. Cada capa calcula sus salidas $x^{out}$.
*   En la retropropagación se calcula el gradiente de la pérdida
$$
\delta_i = \frac{\partial \mathcal{L}}{\partial x_i^{\text{in}}} = \sum_{n=1}^N \delta_n \cdot \frac{\partial x_n^{\text{out}}}{\partial x_i^{\text{in}}},
$$
donde $\delta_i$ se propaga desde la última capa hasta la primera.
*   El descenso por gradiente permite que los parámetros de la red se actualicen.$$
W_{ij} \gets W_{ij} - \epsilon \cdot \frac{\partial \mathcal{L}}{\partial W_{ij}}, \quad b_j \gets b_j - \epsilon \cdot \frac{\partial \mathcal{L}}{\partial b_j},
$$
$\epsilon$ corresponde a la tasa de aprendizaje, la cual permite controlar la dimensión de las actualizaciones a realizar.

*   En cada iteración, se computa la pérdida total $\mathcal{L}$ acumulada sobre todas las muestras de entrenamiento, y se ajustan los parámetros hasta alcanzar un criterio de convergencia o un número máximo de iteraciones.
"""

from tqdm import tqdm

class FeedForward:
    def __init__(self, layer_len, eps=.0001, seed=None, loss=SquaredLoss, **kwargs):
        self.seed = np.random.randint(int(1e4)) if seed is None else int(seed)
        np.random.seed(self.seed)
        self.layer_len = layer_len
        self.eps = eps
        self.n_layers = len(self.layer_len) - 1
        self.layers = [FullyConnectedLayer(layer_len[ii], layer_len[ii + 1], **kwargs) for ii in range(self.n_layers)]
        self.loss = loss(self.layer_len[-1])
        self.loss_hist = None

    def __call__(self, x):
        # forward pass
        x_in = x
        for ll in range(self.n_layers):
            x_in = self.layers[ll](x_in)
        return x_in

    def backprop(self):
        # gradient backpropagation
        delta = self.layers[-1].update_grad(self.loss.dloss_dy)
        for ll in range(self.n_layers - 1)[::-1]:
            delta = self.layers[ll].update_grad(delta)

    def gradient_descent_par(self):
        # update parameters via gradient descent
        for ll in self.layers:
            for nn in ll.neurons:
                nn.gradient_descent(self.eps)

    def train(self, x_train, y_train, n_iter_max=10000, loss_tol=.1):
        self.loss_hist = np.zeros(n_iter_max)
        x_train, y_train = np.array(x_train), np.array(y_train)
        assert x_train.shape[0] == y_train.shape[0], 'x_train, y_train must contain the same number of samples'
        assert x_train.shape[1] == self.layer_len[0], 'shape of x_train is incompatible with first layer'

        pbar = tqdm(range(n_iter_max))
        for it in pbar:
            loss = 0  # reset loss
            for ii in range(x_train.shape[0]):
                x_out = self(x_train[ii, :])  # forward pass
                loss += self.loss(x_out, y_train[ii, :])  # accumulate loss
                self.backprop()  # backward propagation
                [layer.zero_grad(which=['xin']) for layer in self.layers]  # reset gradient wrt xin to zero
            self.loss_hist[it] = loss
            if (it % 10) == 0:
                pbar.set_postfix_str(f'loss: {loss:.3f}')  #
            if loss < loss_tol:
                pbar.set_postfix_str(f'loss: {loss:.3f}. Convergence has been attained!')
                self.loss_hist = self.loss_hist[: it]
                break
            self.gradient_descent_par()  # update parameters
            [layer.zero_grad(which=['weights', 'bias']) for layer in self.layers]  # reset gradient wrt par to zero

"""Del tutorial siguiente, se debe considerar lo siguiente.


> En la práctica, los datos de entrenamiento se entregan en lotes, por lo que la pérdida y los gradientes correspondientes se suman en todos los datos del lote. Dado que los gradientes se acumulan durante el paso hacia atrás, deben reiniciarse a cero después de cada lote.

### Reproducción del tutorial.

En este ultimo paso, se reproducirá el ejemplo del tutorial, utilizando un problema de **regresión de una dimensión simple**, entrenando las KAN y el MLP.

#### Ejemplo 1

Se genera un conjunto de datos basados en una función sinuidal amortiguada. Se tienen entradas $x_{train}$ y salidas $y_{train}$. Se entrena una red KAN y una MLP.
"""

n_iter_train_1d = 500 #Número máximo de iteraciones de entrenamiento.
loss_tol_1d = .05
seed = 476

# Generación de datos de entrenamiento: Función sinusoidal amortiguada.
x_train = np.linspace(-1, 1, 50).reshape(-1, 1)
y_train = .5 * np.sin(4 * x_train) * np.exp(-(x_train+1)) + .5  # damped sinusoid

# KAN training
kan_1d = FeedForward([1, 2, 2, 1],  # layer size
                  eps=.01,  # gradient descent parameter
                  n_weights_per_edge=7,  # n. edge functions
                  neuron_class=NeuronKAN,
                  x_bounds=[-1, 1],  # input domain bounds
                  get_edge_fun=get_bsplines,  # edge function type (B-splines ot Chebyshev)
                  seed=seed,
                  weights_range=[-1, 1])
kan_1d.train(x_train,
          y_train,
          n_iter_max=n_iter_train_1d,
          loss_tol=loss_tol_1d)

# MLP training
mlp_1d = FeedForward([1, 13, 1],  # layer size
                  eps=.005,  # gradient descend parameter
                  activation=relu,  # activation type (ReLU, tanh or sigmoid)
                  neuron_class=NeuronNN,
                  seed=seed,
                  weights_range=[-.5, .5])
mlp_1d.train(x_train,
             y_train,
             n_iter_max=n_iter_train_1d,
             loss_tol=loss_tol_1d)

"""Se visualiza el proceso mediante el siguiente bloque de código."""

import matplotlib.pyplot as plt # import the matplotlib library and assign it to the alias 'plt'

# Define the color_plots dictionary
color_plots = {
    'dataset': 'blue',  # Example color for the dataset
    'kan': 'red',       # Example color for KAN
    'mlp': 'green'      # Example color for MLP
}

# Regression on training data
fig, ax = plt.subplots(figsize=(4,3.2))
x_plot = np.linspace(x_train[0], x_train[-1], 1000).reshape(-1, 1)
ax.plot(x_train, y_train, 'o', color=color_plots['dataset'], label='training dataset')
ax.plot(x_plot, [kan_1d(x) for x in x_plot], color=color_plots['kan'], label='KAN')
ax.plot(x_train, [kan_1d(x) for x in x_train], 'x', color=color_plots['kan'], fillstyle='none')
ax.plot(x_plot, [mlp_1d(x) for x in x_plot], color=color_plots['mlp'], label='MLP')
ax.plot(x_train, [mlp_1d(x) for x in x_train], 'd', color=color_plots['mlp'], fillstyle='none')
ax.set_xlabel('input feature', fontsize=13)
ax.set_title('Regression', fontsize=15)
ax.legend()
ax.grid()
fig.tight_layout()
plt.show()
#fig.savefig(folder_fig + 'regr1D.png', dpi=500)

"""Las predicciones para KAN se muestran en rojo, y en verde para MLP.
 Se puede observar que las curvas para KAN varian de forma más compleja, esto se debe a las funciones de borde (B-splines). La convergencia en KAN se obtuvo más rápido que para MLP, esto se puede observar en la siguiente imagen:

 ![image.png](data:image/png;base64,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)

#### Ejemplo 2
A continuación se presenta un problema de ***regresión 2D*** (se tienen dos entradas) un poco más complejo. Los valores de salida se calculan al evaluar la función en cada punto de la malla.
"""

def fun2d(X1, X2):
    return X1 * np.power(X2, .5)

X1, X2 = np.meshgrid(np.linspace(0, .8, 8), np.linspace(0, 1, 10))
Y_training = fun2d(X1, X2)

x_train2d = np.concatenate((X1.reshape(-1, 1), X2.reshape(-1, 1)), axis=1)
y_train2d = Y_training.reshape(-1, 1)

f, a = plt.subplots(figsize=(3,3))
a.set_xlabel('input feature 1')
a.set_ylabel('input feature 2')
a.pcolor(X1, X2, Y_training)
a.set_title('Training data')
f.tight_layout()
plt.show()

"""El mapa de calor anterior representa las dependencias entre las características ***x1*** y ***x2***.
Se entrena la red KAN y MLP.
"""

n_iter_train_2d = 500
loss_tol_2d = .1
seed = 476

#KAN
kan_2d = FeedForward([2, 2, 1],  # layer size
                  eps=.02,  # gradient descent parameter
                  n_weights_per_edge=10,  # n. edge functions
                  neuron_class=NeuronKAN,
                  x_bounds=[-1, 1],  # input domain bounds
                  get_edge_fun=get_bsplines,  # edge function type (B-splines ot Chebyshev)
                  seed=seed,
                  weights_range=[-1, 1])
kan_2d.train(x_train2d,
          y_train2d,
          n_iter_max=n_iter_train_2d,
          loss_tol=loss_tol_2d)

#MLP
mlp_2d = FeedForward([2, 6, 1],  # layer size
                     eps=.0025,  # gradient descend parameter
                     activation=relu,  # activation type (ReLU, tanh or sigmoid)
                     neuron_class=NeuronNN,
                     seed=seed,
                     weights_range=[-.1, .1])
mlp_2d.train(x_train2d,
             y_train2d,
             n_iter_max=n_iter_train_2d,
             loss_tol=loss_tol_2d)

"""El siguiente bloque es para la visualización de los resultados."""

Y_kan = np.array([kan_2d(xx) for xx in x_train2d])
Y_mlp = np.array([mlp_2d(xx) for xx in x_train2d])

f, a = plt.subplots(1, 3, figsize=(11,3))

vmin, vmax = min(Y_training.flatten()), max(Y_training.flatten())

im0 = a[0].pcolor(X1, X2, Y_training, vmin=vmin, vmax=vmax)
f.colorbar(im0, ax=a[0])
a[0].set_title('Training data')
a[0].set_xlabel('input feature 1')
a[0].set_ylabel('input feature 2')

im1 = a[1].pcolor(X1, X2, Y_kan.reshape(X1.shape), vmin=vmin, vmax=vmax)
f.colorbar(im1, ax=a[1])
a[1].set_title('KAN regression')
a[1].set_xlabel('input feature 1')
a[1].set_ylabel('input feature 2')

im2 = a[2].pcolor(X1, X2, Y_mlp.reshape(X1.shape), vmin=vmin, vmax=vmax)
f.colorbar(im2, ax=a[2])
a[2].set_title('MLP regression')
a[2].set_xlabel('input feature 1')
a[2].set_ylabel('input feature 2')

f.tight_layout()
plt.show()
# f.savefig(folder_fig + 'regr2D.png', dpi=500)

fig1, ax1 = plt.subplots(figsize=(4,3))
ax1.plot(kan_2d.loss_hist, '-', color=color_plots['kan'], label='KAN')
ax1.plot(mlp_2d.loss_hist, '-', color=color_plots['mlp'], label='MLP')
ax1.plot(loss_tol_2d * np.ones(max(len(mlp_2d.loss_hist), len(kan_2d.loss_hist))), '--k')
ax1.grid()
ax1.set_ylabel('squared loss')
ax1.set_xlabel('iteration', fontsize=13)
ax1.legend()
ax1.set_title('Loss evolution')
plt.show()

"""Como se puede observar en la imagen generada,  un mapa de calor para los datos de entrenamiento originales y los valores predichos por los modelos KAN y MLP.
*   Training data: Representa los valores reales de la función objetivo.
*   KAN regression: Muestra la predicción de la red KAN, que ajusta los datos con gran precisión.
*   MLP regression: Muestra la predicción del MLP, que también sigue la tendencia general pero puede ser menos preciso en regiones complejas.

Se puede observar que KAN captura mejor las relaciones no lineales debido a las transformaciones no lineales. En MLP se observa una generalización más limitada. Además, KAN alcanzó la convergencia más rapido que MLP.

#### Ejemplo 3
Se concluye con un problema de ***clasificación en el conjunto de datos en forma de media luna de scikit-learn***. Los datos se observan en el gráfico posterior, coloreados referentes a la clase a la que pertenecen.
"""

from sklearn import datasets

n_samples = 50
noise = 0.1
x_train_cl, y_train_cl = datasets.make_moons(n_samples=n_samples, noise=noise)
# normalize between -1 and 1
x_train_cl[:, 0] = (x_train_cl[:, 0] - min(x_train_cl[:, 0])) / max(x_train_cl[:, 0] - min(x_train_cl[:, 0])) * 2 - 1
x_train_cl[:, 1] = (x_train_cl[:, 1] - min(x_train_cl[:, 1])) / max(x_train_cl[:, 1] - min(x_train_cl[:, 1])) * 2 - 1

fig, ax = plt.subplots(figsize=(4,3))
ax.scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
ax.set_xlabel('input feature 1')
ax.set_ylabel('input feature 2')
ax.grid()
ax.set_title("Training data")
plt.show()

"""A continuación se realiza el entrenamiento de los modelos MLP(dos capas ocultas de 10 neuronas cada una) y KAN (una capa de 2 neuronas). Para ambos se utiliza entropía cruzada como función de perdida ya que es un problema de clasificación."""

#parametros
n_iter_train_cl = int(1e3)
loss_tol_cl = 1.5
seed = 476

#MLP
mlp_cl = FeedForward([2, 10, 10, 2],  # layer size
                     eps=.01,  # gradient descend parameter
                     activation=tanh_act,  # activation type (relu, tanh_act or sigmoid_act)
                     neuron_class=NeuronNN,
                     loss=CrossEntropyLoss,
                     seed=seed,
                     weights_range=[-1, 1])
mlp_cl.train(x_train_cl,
             y_train_cl.reshape(-1, 1),
             n_iter_max=n_iter_train_cl,
             loss_tol=loss_tol_cl)

#KAN
kan_cl = FeedForward([2, 2],  # layer size
                     eps=.02,  # gradient descent parameter
                     n_weights_per_edge=8,  # n. edge functions
                     neuron_class=NeuronKAN,
                     loss=CrossEntropyLoss,
                     x_bounds=[-1, 1],  # input domain bounds
                     get_edge_fun=get_bsplines,  # edge function type (B-splines ot Chebyshev)
                     seed=seed,
                     weights_range=[-1, 1])
kan_cl.train(x_train_cl,
             y_train_cl.reshape(-1, 1),
             n_iter_max=n_iter_train_cl,
             loss_tol=loss_tol_cl)

#plot
def softmax(vec):
    return np.exp(vec) / sum(np.exp(vec))

X1_cl, X2_cl = np.meshgrid(np.linspace(-1, 1, 40), np.linspace(-1, 1, 50))
x_cl = np.concatenate((X1_cl.reshape(-1, 1), X2_cl.reshape(-1, 1)), axis=1)

Y_kan_cl = np.array([softmax(kan_cl(x))[1] for x in x_cl]).reshape(X1_cl.shape)
Y_mlp_cl = np.array([softmax(mlp_cl(x))[1] for x in x_cl]).reshape(X1_cl.shape)

fig_cl, ax_cl = plt.subplots(1, 3, figsize=(12,3))
# vmin, vmax = min(Y_training.flatten()), max(Y_training.flatten())

ax_cl[0].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
ax_cl[0].grid()
ax_cl[0].set_title('Training data')
ax_cl[0].set_xlabel('input feature 1')
ax_cl[0].set_ylabel('input feature 2')

im0 = ax_cl[1].pcolor(X1_cl, X2_cl, Y_kan_cl, vmin=0, vmax=1, cmap=plt.cm.bwr)
ax_cl[1].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
ax_cl[1].set_title('KAN classification')
ax_cl[1].set_xlabel('input feature 1')
ax_cl[1].set_ylabel('input feature 2')

im1 = ax_cl[2].pcolor(X1_cl, X2_cl, Y_mlp_cl, vmin=0, vmax=1, cmap=plt.cm.bwr)
ax_cl[2].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
ax_cl[2].set_title('MLP classification')
ax_cl[2].set_xlabel('input feature 1')
ax_cl[2].set_ylabel('input feature 2')

fig_cl.colorbar(im1, ax=ax_cl[0])
fig_cl.colorbar(im1, ax=ax_cl[1])
fig_cl.colorbar(im1, ax=ax_cl[2])
fig_cl.tight_layout()
plt.show()
# fig_cl.savefig(folder_fig + 'classification.png', dpi=500)

"""Se observan los datos de entrenamiento mediante un mapa de calior que ilustra la probabilidad asignada por los modelos para cada clase en el dominio. Los puntos representan los datos de entrenamiento y se observa cómo ambos modelos trazan los límites de decisión.
Se observa que KAN puede capturar patrones más complejos debido a sus transformaciones basadas en B-splines, tal como ha ocurrido en los ejemplos anteriores.

## Item 2. Modificación y Comparación de Resultados

### Ejemplo 1

Para este apartado se realiza el ejemplo de regresión, comparando con el realizado por el tutorial mediante la creación de un ejemplo de regresión para datos con una distribución compleja y otra lineal.

En este proceso, se generan datos con una distribución cúbica con ruido introducido para observar cómo los modelos KAN y MLP responden a estos datos. Posteriormente se observan tres gráficos: Los datos generados sobre el eje $x$ e $y$, Las curvas generadas por el modelo por sobre los datos, y la evolución del valor de LOSS para ambos modelos mediante las iteraciones de entrenamiento.
"""

# @title Datos con tendencia cúbica y entrenamiento.
import numpy as np
import matplotlib.pyplot as plt

# Colores para gráficos
color_plots = {'dataset': 'blue', 'kan': 'orange', 'mlp': 'green'}

# Generar un nuevo conjunto de datos (distribución polinómica con ruido)
np.random.seed(42)
x_train = np.linspace(-1, 1, 50).reshape(-1, 1)
y_train = 0.8 * (x_train**3) - 0.5 * (x_train**2) + 0.3 * x_train + 0.2  # función cúbica
y_train += 0.1 * np.random.normal(size=y_train.shape)  # agregar ruido

# Parámetros de entrenamiento
n_iter_train_1d = 500
loss_tol_1d = 0.05
seed = 476

# Entrenamiento de KAN
kan_1d = FeedForward(
    [1, 2, 2, 1],  # tamaño de capas
    eps=0.01,  # parámetro de descenso de gradiente
    n_weights_per_edge=7,  # número de funciones por conexión
    neuron_class=NeuronKAN,
    x_bounds=[-1, 1],  # límites del dominio de entrada
    get_edge_fun=get_bsplines,  # tipo de funciones de borde (B-splines o Chebyshev)
    seed=seed,
    weights_range=[-1, 1]
)
kan_1d.train(x_train, y_train, n_iter_max=n_iter_train_1d, loss_tol=loss_tol_1d)

# Entrenamiento de MLP
mlp_1d = FeedForward(
    [1, 13, 1],  # tamaño de capas
    eps=0.005,  # parámetro de descenso de gradiente
    activation=relu,  # tipo de activación (ReLU, tanh o sigmoide)
    neuron_class=NeuronNN,
    seed=seed,
    weights_range=[-0.5, 0.5]
)
mlp_1d.train(x_train, y_train, n_iter_max=n_iter_train_1d, loss_tol=loss_tol_1d)



# Crear los gráficos
fig, ax = plt.subplots(1, 3, figsize=(15, 4))

# Primer gráfico: Datos de entrenamiento
ax[0].plot(x_train, y_train, 'o', color=color_plots['dataset'], markersize=4, label='Training Data')
ax[0].set_title('Training Data (Linear)')
ax[0].grid()
ax[0].legend()

# Segundo gráfico: Resultados KAN vs MLP
x_plot = np.linspace(-1, 1, 1000).reshape(-1, 1)  # puntos para predicciones
y_kan_pred = np.array([kan_1d(x) for x in x_plot])  # predicción con KAN
y_mlp_pred = np.array([mlp_1d(x) for x in x_plot])  # predicción con MLP

ax[1].plot(x_train, y_train, 'o', color=color_plots['dataset'], markersize=4, label='Training Data')  # Reducir tamaño de los puntos
ax[1].plot(x_plot, y_kan_pred, '-', color=color_plots['kan'], linewidth=2, label='KAN')  # Aumentar grosor de la línea
ax[1].plot(x_plot, y_mlp_pred, '-', color=color_plots['mlp'], linewidth=2, label='MLP')  # Aumentar grosor de la línea
ax[1].set_title('Regression: KAN vs MLP')
ax[1].grid()
ax[1].legend()

# Tercer gráfico: Evolución del loss
ax[2].plot(kan_1d.loss_hist, '-', color=color_plots['kan'], linewidth=1.5, label='KAN Loss')
ax[2].plot(mlp_1d.loss_hist, '-', color=color_plots['mlp'], linewidth=1.5, label='MLP Loss')
ax[2].plot(loss_tol_1d * np.ones(max(len(mlp_1d.loss_hist), len(kan_1d.loss_hist))), '--k', label='Loss Tolerance')
ax[2].set_title('Loss Evolution')
ax[2].set_xlabel('Iterations')
ax[2].set_ylabel('Loss')
ax[2].grid()
ax[2].legend()

# Ajustar el diseño
fig.tight_layout()
plt.show()

"""Para los datos generados, se observa que el modelo KAN representa de manera más precisa los datos en comparación al modelo MLP. Algo interesante a analizar es que KAN inicia con un Loss elevado, pero este valor decrece rápidamente a mayor cantidad de iteraciones de entrenamiento, alcanzando una precisión significativamente mejor que la obtenida por MLP.

Esto se explica por la forma en que ambos algoritmos procesan los datos. KAN utiliza las funciónes borde (b-spline), lo que le permite representar relaciones más complejas y no lineales entre las entradas, por lo que el modelo se ajusta mejor a esta distribución de los datos, a diferencia de MLP aproxima las relaciones de los datos con funciones más simples, observando así la relación de los datos con forma lineal hecha por MLP menos representativa de los datos.

Se presenta la siguiente imagen, la cual son los resultados obtenidos del entrenamiento para el primer ejemplo de regresión realizado en el tutorial con el fin de su posterior comparación y análisis.

![image.png](data:image/png;base64,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)

Al observar los datos obtenidos en el ejemplo 1 del tutorial, se aprecia un caso muy similar al comentado recientemente. Si bien ambos alcanzaron una convergencia adecuada para el valor de loss (Loss = 0,05), MLP tardo más iteraciones en alcanzar esta convergencia. Para ambas distribuciones complejas de los datos generados se obtuvo una mejora en el valor de LOSS más rapida para KAN que para MLP. Nuevamente se entiende que esto puede deberse a la capacidad de KAN de detectar comportamientos complejos en los datos, donde para ambos ejemplos obtuvo una forma con curvas más suaves y para MLP un comportamiento lineal.

De ambos ejemplos se puede entender que KAN no solo es más eficiente en la cantidad de iteraciones necesarias para converger al valor definido de loss, si no que también demuestra mayor capacidad para ajustarse a distribuciones complejas. De aquí surge la siguiente pregunta:

**¿KAN es mejor que MLP en todo tipo de distribución de datos?**


Para responder a lo anterior, se genera un ejemplo con una distribución lineal $y = 2x+1$, con ruido introducido.
"""

# @title Datos con tendencia cúbica y entrenamiento.
import numpy as np
import matplotlib.pyplot as plt

# Colores para gráficos
color_plots = {'dataset': 'blue', 'kan': 'orange', 'mlp': 'green'}

# Generar un nuevo conjunto de datos (distribución polinómica con ruido)
np.random.seed(42)
x_train = np.linspace(-1, 1, 50).reshape(-1, 1)
y_train = 0.8 * (x_train**3) - 0.5 * (x_train**2) + 0.3 * x_train + 0.2  # función cúbica
y_train += 0.1 * np.random.normal(size=y_train.shape)  # agregar ruido

# Parámetros de entrenamiento
n_iter_train_1d = 500
loss_tol_1d = 0.05
seed = 476

# Entrenamiento de KAN
kan_1d = FeedForward(
    [1, 2, 2, 1],  # tamaño de capas
    eps=0.01,  # parámetro de descenso de gradiente
    n_weights_per_edge=7,  # número de funciones por conexión
    neuron_class=NeuronKAN,
    x_bounds=[-1, 1],  # límites del dominio de entrada
    get_edge_fun=get_bsplines,  # tipo de funciones de borde (B-splines o Chebyshev)
    seed=seed,
    weights_range=[-1, 1]
)
kan_1d.train(x_train, y_train, n_iter_max=n_iter_train_1d, loss_tol=loss_tol_1d)

# Entrenamiento de MLP
mlp_1d = FeedForward(
    [1, 13, 1],  # tamaño de capas
    eps=0.005,  # parámetro de descenso de gradiente
    activation=relu,  # tipo de activación (ReLU, tanh o sigmoide)
    neuron_class=NeuronNN,
    seed=seed,
    weights_range=[-0.5, 0.5]
)
mlp_1d.train(x_train, y_train, n_iter_max=n_iter_train_1d, loss_tol=loss_tol_1d)



# Crear los gráficos
fig, ax = plt.subplots(1, 3, figsize=(15, 4))

# Primer gráfico: Datos de entrenamiento
ax[0].plot(x_train, y_train, 'o', color=color_plots['dataset'], markersize=4, label='Training Data')
ax[0].set_title('Training Data (Linear)')
ax[0].grid()
ax[0].legend()

# Segundo gráfico: Resultados KAN vs MLP
x_plot = np.linspace(-1, 1, 1000).reshape(-1, 1)  # puntos para predicciones
y_kan_pred = np.array([kan_1d(x) for x in x_plot])  # predicción con KAN
y_mlp_pred = np.array([mlp_1d(x) for x in x_plot])  # predicción con MLP

ax[1].plot(x_train, y_train, 'o', color=color_plots['dataset'], markersize=4, label='Training Data')  # Reducir tamaño de los puntos
ax[1].plot(x_plot, y_kan_pred, '-', color=color_plots['kan'], linewidth=2, label='KAN')  # Aumentar grosor de la línea
ax[1].plot(x_plot, y_mlp_pred, '-', color=color_plots['mlp'], linewidth=2, label='MLP')  # Aumentar grosor de la línea
ax[1].set_title('Regression: KAN vs MLP')
ax[1].grid()
ax[1].legend()

# Tercer gráfico: Evolución del loss
ax[2].plot(kan_1d.loss_hist, '-', color=color_plots['kan'], linewidth=1.5, label='KAN Loss')
ax[2].plot(mlp_1d.loss_hist, '-', color=color_plots['mlp'], linewidth=1.5, label='MLP Loss')
ax[2].plot(loss_tol_1d * np.ones(max(len(mlp_1d.loss_hist), len(kan_1d.loss_hist))), '--k', label='Loss Tolerance')
ax[2].set_title('Loss Evolution')
ax[2].set_xlabel('Iterations')
ax[2].set_ylabel('Loss')
ax[2].grid()
ax[2].legend()

# Ajustar el diseño
fig.tight_layout()
plt.show()

# @title Datos con distribución lineal
import numpy as np
import matplotlib.pyplot as plt

# Colores para gráficos
color_plots = {'dataset': 'blue', 'kan': 'orange', 'mlp': 'green'}

# Generar datos lineales con ruido
np.random.seed(42)
x_train_linear = np.linspace(-1, 1, 50).reshape(-1, 1)  # 50 puntos entre -1 y 1
y_train_linear = 2 * x_train_linear + 1  # y = 2x + 1
y_train_linear += 0.1 * np.random.normal(size=y_train_linear.shape)  # agregar ruido

# Parámetros de entrenamiento
n_iter_train_linear = 500
loss_tol_linear = 0.05
seed = 476

# Entrenamiento de KAN
kan_linear = FeedForward(
    [1, 2, 2, 1],  # tamaño de capas
    eps=0.01,  # parámetro de descenso de gradiente
    n_weights_per_edge=7,  # número de funciones por conexión
    neuron_class=NeuronKAN,
    x_bounds=[-1, 1],  # límites del dominio de entrada
    get_edge_fun=get_bsplines,  # tipo de funciones de borde (B-splines o Chebyshev)
    seed=seed,
    weights_range=[-1, 1]
)
kan_linear.train(x_train_linear, y_train_linear, n_iter_max=n_iter_train_linear, loss_tol=loss_tol_linear)

# Entrenamiento de MLP
mlp_linear = FeedForward(
    [1, 13, 1],  # tamaño de capas
    eps=0.005,  # parámetro de descenso de gradiente
    activation=relu,  # tipo de activación (ReLU, tanh o sigmoide)
    neuron_class=NeuronNN,
    seed=seed,
    weights_range=[-0.5, 0.5]
)
mlp_linear.train(x_train_linear, y_train_linear, n_iter_max=n_iter_train_linear, loss_tol=loss_tol_linear)


# Visualizar los datos y los resultados en una fila de gráficos
fig, ax = plt.subplots(1, 3, figsize=(15, 4))  # Crear una figura con 3 subgráficos uno al lado del otro

# Primer gráfico: Visualización de los datos de entrenamiento
ax[0].plot(x_train_linear, y_train_linear, 'o', color=color_plots['dataset'], label='Training Data')
ax[0].set_title('Training Data (Linear)')
ax[0].grid()
ax[0].legend()

# Segundo gráfico: Resultados KAN vs MLP
x_plot = np.linspace(-1, 1, 1000).reshape(-1, 1)  # puntos para predicciones
y_kan_pred = np.array([kan_linear(x) for x in x_plot])  # predicción con KAN
y_mlp_pred = np.array([mlp_linear(x) for x in x_plot])  # predicción con MLP

# Ajustar tamaño de los puntos de entrenamiento y grosor de las líneas
ax[1].plot(x_train_linear, y_train_linear, 'o', color=color_plots['dataset'], markersize=4, label='Training Data')  # Reducir tamaño de los puntos
ax[1].plot(x_plot, y_kan_pred, '-', color=color_plots['kan'], linewidth=2, label='KAN')  # Aumentar grosor de la línea
ax[1].plot(x_plot, y_mlp_pred, '-', color=color_plots['mlp'], linewidth=2, label='MLP')  # Aumentar grosor de la línea
ax[1].set_title('Linear Regression: KAN vs MLP')
ax[1].grid()
ax[1].legend()

# Tercer gráfico: Comportamiento del Loss vs Iteraciones
ax[2].plot(range(len(kan_linear.loss_hist)), kan_linear.loss_hist, color=color_plots['kan'], label='KAN Loss', linewidth=2)
ax[2].plot(range(len(mlp_linear.loss_hist)), mlp_linear.loss_hist, color=color_plots['mlp'], label='MLP Loss', linewidth=2)
ax[2].set_title('Loss vs Iterations')
ax[2].set_xlabel('Iterations')
ax[2].set_ylabel('Loss')
ax[2].grid()
ax[2].legend()

# Ajustar el diseño
fig.tight_layout()
plt.show()

"""En este caso, KAN no ofrece ventajas significativas a diferencia de los casos presentados anteriormente. MLP genera una mejor representación gracias a su arquitectura más simple, siendo capaz de ajustarse con mayor precisión a la tendencia lineal de los datos.

 Como KAN introduce una complejidad adicional, su representación tiende a agregar curvas o patrones innecesario debido al uso de las funciones borde. Esto se puede observar en el gráfico, donde a partir del punto x1=0, desvía su forma del comportamiento esperado de los datos. Esto resulta en una perdida adicional y un loss con un valor mucho más alto que el obtenido para MLP.

  En base al gráfico loss vs Iterations observado, MLP tiene un Loss mejor que KAN para muchas iteraciones, además de una rápida convergencia del valor de pérdida, solidificando lo fundamentado anteriormente.

  Otra observación a realizar es que MLP no toma valores negativos para $y$, esto puede deberse a la función de activación RelU utilizada, la cual toma los valores negativos como 0 a lo largo de la propagación hacia adelante.

### Ejemplo 2
Para este segundo apartado se realiza el ejemplo de regresión 2D, comparandolo con el realizado en el tutorial junto con los nuevos datos de entrenamiento utilizando distribución lineal.

Este código genera una visualización completa de los datos y resultados obtenidos al aplicar los modelos KAN y MLP sobre un conjunto de datos distribuidos linealmente.

El código siguiente genera datos distribuidos linealmente. Se les aplica KAN y MLP para su posterior comparación con el Ejemplo 2 del tutorial. Se presentan cuatro gráficos: los datos de generados, las predicciones realizadas por el modelo KAN, las predicciones del modelo MLP y la evolución de la pérdida ante iteraciones del entrenamiento de ambos modelos.

Dado que para el ejemplo 1 ya se realizaron ejemplos de regresión ante datos con distribución compleja y lineal, en este apartado se hace hincapié unicamente en la regresión con datos distribuidos linealmente para su posterior comparación con el ejemplo de regresión con datos complejamente distribuidos del tutorial.
"""

# @title Datos con distribución lineal y aplicación de MLP y KAN.
import numpy as np
import matplotlib.pyplot as plt

# Cambiamos la función para generar una distribución lineal
def fun2d_linear(X1, X2):
    return 0.5 * X1 + 0.3 * X2

X1, X2 = np.meshgrid(np.linspace(0, .8, 8), np.linspace(0, 1, 10))
Y_training = fun2d_linear(X1, X2)

x_train2d = np.concatenate((X1.reshape(-1, 1), X2.reshape(-1, 1)), axis=1)
y_train2d = Y_training.reshape(-1, 1)

# Parámetros de entrenamiento
n_iter_train_2d = 500
loss_tol_2d = 0.01
seed = 476

# KAN con datos lineales
kan_2d = FeedForward(
    [2, 2, 1],  # tamaño de las capas
    eps=0.02,  # parámetro de gradiente
    n_weights_per_edge=10,  # funciones por arista
    neuron_class=NeuronKAN,
    x_bounds=[-1, 1],  # límites del dominio
    get_edge_fun=get_bsplines,  # funciones de base (B-splines)
    seed=seed,
    weights_range=[-1, 1]
)
kan_2d.train(
    x_train2d,
    y_train2d,
    n_iter_max=n_iter_train_2d,
    loss_tol=loss_tol_2d
)

# MLP con datos lineales para comparación
mlp_2d = FeedForward(
    [2, 6, 1],  # tamaño de las capas
    eps=0.0025,  # parámetro de gradiente
    activation=relu,  # tipo de activación
    neuron_class=NeuronNN,
    seed=seed,
    weights_range=[-0.1, 0.1]
)
mlp_2d.train(
    x_train2d,
    y_train2d,
    n_iter_max=n_iter_train_2d,
    loss_tol=loss_tol_2d
)


# Código del bloque 2 (Gráficos de los resultados)
Y_kan = np.array([kan_2d(xx) for xx in x_train2d])
Y_mlp = np.array([mlp_2d(xx) for xx in x_train2d])

# Crear una figura para concatenar las imágenes
fig_concat, axs_concat = plt.subplots(1, 4, figsize=(16, 4))  # 4 gráficos lado a lado

# Gráfico 1: Training Data (Bloque 1)
vmin, vmax = min(Y_training.flatten()), max(Y_training.flatten())
im0 = axs_concat[0].pcolor(X1, X2, Y_training, vmin=vmin, vmax=vmax, shading='auto')
fig_concat.colorbar(im0, ax=axs_concat[0])
axs_concat[0].set_title('Training Data')
axs_concat[0].set_xlabel('Input feature 1')
axs_concat[0].set_ylabel('Input feature 2')

# Gráfico 2: KAN regression (Bloque 2)
im1 = axs_concat[1].pcolor(X1, X2, Y_kan.reshape(X1.shape), vmin=vmin, vmax=vmax, shading='auto')
fig_concat.colorbar(im1, ax=axs_concat[1])
axs_concat[1].set_title('KAN Regression')
axs_concat[1].set_xlabel('Input feature 1')
axs_concat[1].set_ylabel('Input feature 2')

# Gráfico 3: MLP regression (Bloque 2)
im2 = axs_concat[2].pcolor(X1, X2, Y_mlp.reshape(X1.shape), vmin=vmin, vmax=vmax, shading='auto')
fig_concat.colorbar(im2, ax=axs_concat[2])
axs_concat[2].set_title('MLP Regression')
axs_concat[2].set_xlabel('Input feature 1')
axs_concat[2].set_ylabel('Input feature 2')

# Gráfico 4: Loss evolution (Bloque 3)
axs_concat[3].plot(kan_2d.loss_hist, '-', label='KAN', color='blue')  # Ajusta color según tu esquema
axs_concat[3].plot(mlp_2d.loss_hist, '-', label='MLP', color='orange')  # Ajusta color según tu esquema
axs_concat[3].plot(loss_tol_2d * np.ones(max(len(mlp_2d.loss_hist), len(kan_2d.loss_hist))), '--k')
axs_concat[3].grid()
axs_concat[3].set_ylabel('Squared Loss')
axs_concat[3].set_xlabel('Iteration')
axs_concat[3].legend()
axs_concat[3].set_title('Loss Evolution')

# Ajustar y mostrar todo
fig_concat.tight_layout()
plt.show()

# Si deseas guardar el gráfico completo concatenado
# fig_concat.savefig('combined_graphics.png', dpi=300)

"""En el gráfico de Loss v/s iteraciones se pude observar a simple vista un mejor comportamiento de KAN sobre MLP para las primeras iteraciones, ya que la curva de loss de KAN está por debajo de la de KAN para el primer rango de iteraciones. Sin embargo, se puede observar que la convergencia del valor de LOSS para MLP se alcanzó con mayor velocidad que para KAN, por lo que se puede entender que, a partir de cierta cantidad de iteraciones MLP funciona mucho mejor para datos con este tipo de distribución.

Aún así, KAN se adaptó adecuadamente a la relación lineal. La salida es consistente con lo esperado y el valor de LOSS es considerablemente bajo y aceptable.

Al igual que para el ejemplo 1, MLP obtuvo mejor rendimiento sobre datos con distribución lineal que KAN, mientras que KAN tiene mejor rendimiento sobre datos con distribución compleja que MLP.

### Ejemplo 3

Para este apartado se realiza el ejemplo de clasificación con datos generados (primero con una relación entre los datos compleja y luego una lineal) y se compara el resultado obtenido en KAN-MLP y también con el resultado obtenido en el ejemplo 3 de clasificación del tutorial.

A continuación se generaron datos de entrenamiento con una distribución compleja, específicamente círculos concéntricos con un nivel moderado de ruido, para evaluar la capacidad de dos modelos (KAN y MLP) en resolver problemas de clasificación no lineal. La idea es que los modelos identifiquen los dos grupos generados, donde cada uno pertenece a distintas regiones de los circulos cocéntricos.
Ambos modelos fueron entrenados utilizando estos datos y se generaron gráficos para analizar su desempeño: Los datos generados sobre el plano $(x,y)$, las predicciones realizadas por cada modelo (KAN y MLP) destacando las regiones clasificadas según las probabilidades asignadas, y la evolución de la pérdida (loss) durante el proceso de entrenamiento. Estos resultados permiten comparar visualmente cómo cada modelo ajusta su capacidad de clasificación a una estructura más compleja y cómo evolucionan hacia la convergencia durante el entrenamiento.
"""

# @title Ejemplo de clasificación con datos con distribución compleja.

import numpy as np
import matplotlib.pyplot as plt
from sklearn import datasets

# Definición de la función softmax
def softmax(z):
    e_z = np.exp(z - np.max(z))  # Estabilidad numérica
    return e_z / e_z.sum(axis=-1, keepdims=True)

# Crear nuevos datos con una forma diferente (círculos)
n_samples = 100
noise = 0.12
x_train_cl, y_train_cl = datasets.make_circles(n_samples=n_samples, noise=noise, factor=0.5)

# Normalizar entre -1 y 1
x_train_cl[:, 0] = (x_train_cl[:, 0] - min(x_train_cl[:, 0])) / max(x_train_cl[:, 0] - min(x_train_cl[:, 0])) * 2 - 1
x_train_cl[:, 1] = (x_train_cl[:, 1] - min(x_train_cl[:, 1])) / max(x_train_cl[:, 1] - min(x_train_cl[:, 1])) * 2 - 1

# Parámetros
n_iter_train_cl = int(1e3)
loss_tol_cl = 0.01
seed = 476

# Crear la malla de puntos de prueba en el rango [-1, 1]
X1_cl, X2_cl = np.meshgrid(np.linspace(-1, 1, 40), np.linspace(-1, 1, 50))
x_cl = np.concatenate((X1_cl.reshape(-1, 1), X2_cl.reshape(-1, 1)), axis=1)

# MLP
mlp_cl = FeedForward([2, 5, 2],  # layer size
                     eps=.01,  # gradient descend parameter
                     activation=relu,  # activation type (relu, tanh_act or sigmoid_act)
                     neuron_class=NeuronNN,
                     loss=CrossEntropyLoss,
                     seed=seed,
                     weights_range=[-0.5, 0.5])
mlp_cl.train(x_train_cl,
             y_train_cl.reshape(-1, 1),
             n_iter_max=n_iter_train_cl,
             loss_tol=loss_tol_cl)

# KAN
kan_cl = FeedForward([2, 2],  # layer size
                     eps=.01,  # gradient descent parameter
                     n_weights_per_edge=8,  # n. edge functions
                     neuron_class=NeuronKAN,
                     loss=CrossEntropyLoss,
                     x_bounds=[-1, 1],  # input domain bounds
                     get_edge_fun=get_bsplines,  # edge function type (B-splines or Chebyshev)
                     seed=seed,
                     weights_range=[-0.5, 0.5])
kan_cl.train(x_train_cl,
             y_train_cl.reshape(-1, 1),
             n_iter_max=n_iter_train_cl,
             loss_tol=loss_tol_cl)

# Paso 1: Visualizar datos de entrenamiento
fig_concat, axs_concat = plt.subplots(1, 4, figsize=(18, 4))

# Datos de entrenamiento (círculos concéntricos)
axs_concat[0].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
axs_concat[0].set_xlabel('Input feature 1')
axs_concat[0].set_ylabel('Input feature 2')
axs_concat[0].set_title('Training Data')
axs_concat[0].set_aspect('equal')
axs_concat[0].grid()

# Clasificación KAN
Y_kan_cl = np.array([softmax(kan_cl(x))[1] for x in x_cl]).reshape(X1_cl.shape)
im0 = axs_concat[1].pcolor(X1_cl, X2_cl, Y_kan_cl, vmin=0, vmax=1, cmap=plt.cm.bwr)
axs_concat[1].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
axs_concat[1].set_xlabel('Input feature 1')
axs_concat[1].set_ylabel('Input feature 2')
axs_concat[1].set_title('KAN Classification')
axs_concat[1].set_aspect('equal')
fig_concat.colorbar(im0, ax=axs_concat[1])

# Clasificación MLP
Y_mlp_cl = np.array([softmax(mlp_cl(x))[1] for x in x_cl]).reshape(X1_cl.shape)
im1 = axs_concat[2].pcolor(X1_cl, X2_cl, Y_mlp_cl, vmin=0, vmax=1, cmap=plt.cm.bwr)
axs_concat[2].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr)
axs_concat[2].set_xlabel('Input feature 1')
axs_concat[2].set_ylabel('Input feature 2')
axs_concat[2].set_title('MLP Classification')
axs_concat[2].set_aspect('equal')
fig_concat.colorbar(im1, ax=axs_concat[2])

# Evolución de la pérdida
axs_concat[3].plot(kan_cl.loss_hist, label='KAN', color='blue')
axs_concat[3].plot(mlp_cl.loss_hist, label='MLP', color='orange')
axs_concat[3].plot(loss_tol_cl * np.ones(max(len(mlp_cl.loss_hist), len(kan_cl.loss_hist))), '--k')
axs_concat[3].set_xlabel('Iteration')
axs_concat[3].set_ylabel('Loss')
axs_concat[3].set_title('Loss Evolution')
axs_concat[3].legend()
axs_concat[3].grid()

# Ajustar y mostrar
fig_concat.tight_layout()
plt.show()

# Guardar el gráfico completo concatenado si es necesario
# fig_concat.savefig('combined_classification_results.png', dpi=300)

"""De los resultados se obtiene el comportamiento esperado, donde KAN obtiene una mejor respuesta ante la distribución dada de los datos. Al observar la gráfica de Loss v/s Iteraciones, se observa que KAN tiene menor pérdida ante MLP para este problema. Esto se debe a la mejor representación de los datos por parte de KAN, el cual en base a funciones de activación spline se obtiene una mayor flexibilidad y suavidad en las curvas generadas. Esto permite manejar problemas complejos y no lineales, como se observa en la figura redonda de la región.

MLP logra distinguir la clase del grupo azul, pero la clase del grupo rojo se representa por un área blanca, lo que indica que el modelo tiene baja confianza para clasificar los datos de tal clase, y además se genera una región de decisión que tiene bordes rígidos y angulares. Esto, y los valores de LOSS altos, refuerza la idea de que MLP no representa precisamente datos con una distribución compleja.

A continuación se presenta el ejemplo 3 realizado por el tutorial, que aborda un problema muy similar pero ante una distribución distinta de los datos.

![image.png](data:image/png;base64,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C5NKuNjlFrWbM2cO2RGB1sxNcN1CdWr3888/41G466+/vkGDBqQJgpzKtTxz586VJMlqtXJ1EJket4Cgdh43qU8rxNSO9ltTPb7++uv+/fvHxMQowYsM/QMApnazZs2i5xIomT59OslhXCtJkkaPHq0snJycPHz4cAAgL/9jjz2m/HXSpEnOqB0ZUnv33XeV5dPT05XUbvXq1R06dAgNDaUX0qxZM1KeS+1+//33CRMmxMXF0fKSJD3++OPKJkRaWEBYgGsB4jatWbOmfv36DRs2/Oabb5hib775piRJmzZtOvzn36233pqUlEQ7ianjBQDKgTuVUbuNGzdKkrRr1y6mLXLI4M+ePXt69uxJ9nSi7zjpFK+srLz55purRtViYmJKSkpWrlxJ5yn8+uuvbdu2rYosl5SUdNdddyk5HuOZqVO7Nm3a4KCgVO3XX389MzPTYrFQxUwmE/1Vndo99dRTkiR9//33tHzVkum0tLSuXbuSnPz8/DZt2ih/HTZsWEpKijJHpIUFAt4CSoTp3bt3//79V69ebTabyZi/W9SuKsbvrl273nnnnT179vz666/OTHfixAlJkh5++GFuAQZA/ve//w0bNqxu3boUBCRJWrNmDTl33rx5QUFBoaGhVZERnn766V9++YXkq2CXW9Ru9OjRQUFBzjr61d1CdWr30UcfSZL04osvKo0wceLEqsU+58+fr8okyKmM1k7u1E8//aQ8RaS9ZwFB7bxnW1/UjKkd0x1+5syZ+vXrN2vWbP78+a+//vquXbuefvpp5ba8mNoxkwTo3O6q62FcK7xRTHJyMokK4HFqt27duqrBxv79+69du3bHjh27du0qLCyk8Xm51K5nz57h4eGPPfbY5s2bd+7cuWPHDuW1+OL2iDaEBfzWAtRt+vjjj6Oiopo0aXLkyBHl1QwZMkTpstA0jW9EayBnDR8+nAzceYTafffddxaLpVOnTsuWLXvzzTd37dpFeo7oeg8A+Oijjx566KEuXbpUxZFr3779uXPniCalpaXbtm0bM2ZMSkqKJEl0HhHjmemmdh988IHJZMrPz3/xxRe3b9++a9cuYitqvepTOwbnlTBOWxEJYYHAtoASYdauXWuxWLp3706H1NyidswL5cxu2qldeXl5q1atGjRoMGvWrK1bt+7atWv16tXMrt/ffffdM888c91115nN5tjY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)

Ambos ejemplos de clasificación de datos con una distribución no lineal, teniendo mejor desempeño para KAN. Esto refuerza una vez más que KAN captura mejor las relaciones no lineales. Aún así, para este ejemplo MLP si logró adaptarse adecuadamente a la distribución de los datos a pesar de no tener una distribución lineal. Esto se debe principalmente a los distintos parámetros utilizados, ya que se usaron distintas funciones de activación (Tangente hiperbólica para el ejemplo del tutorial y ReLU para el ejemplo generado con los circulos cocéntricos) además de la cantidad de capas y neuronas en la red.

En el siguiente bloque de código se busca realizar un ejemplo para clasificación con una distribución lineal de los datos con el fin de observar el comportamiento de ambos modelos. Se generan dos grupos de datos que son linealmente separables en el espacio. Se entrenan con ambos modelos y se comparan posteriormente.
"""

# @title Ejemplo con datos con una distribución lineal para clasificación.
import numpy as np
import matplotlib.pyplot as plt

# Generar datos replicando la distribución de la imagen
def generate_refined_data(n_samples, noise_level=0.05, seed=42):
    """
    Genera un problema de clasificación con puntos azules concentrados,
    pero con algunos dispersos alrededor.

    Parameters:
        - n_samples: Total de puntos (se dividirá entre las dos clases).
        - noise_level: Nivel de ruido para simular variabilidad real.
        - seed: Semilla para reproducibilidad.

    Returns:
        - X: Array de características (n_samples, 2).
        - y: Etiquetas de clase (0 o 1).
    """
    np.random.seed(seed)

    # Dividir el número de muestras entre las dos clases
    n_blue = n_samples // 2
    n_red = n_samples - n_blue

    # Generar puntos azules (concentrados en un centro)
    center_x1 = np.random.uniform(-0.5, 0.5, int(0.8 * n_blue))  # 80% en el centro
    center_x2 = np.random.uniform(-0.8, -0.2, int(0.8 * n_blue))  # Más concentrados
    outer_x1 = np.random.uniform(-1, 1, int(0.2 * n_blue))  # 20% más dispersos
    outer_x2 = np.random.uniform(-1, 0, int(0.2 * n_blue))  # Más alejados

    x1_blue = np.concatenate((center_x1, outer_x1))
    x2_blue = np.concatenate((center_x2, outer_x2))

    # Generar puntos rojos (distribuidos cerca de la línea divisoria)
    x1_red = np.random.uniform(-0.5, 1, n_red)
    x2_red = -x1_red + 0.5 + np.random.normal(0, noise_level, n_red)  # Alrededor de la línea

    # Etiquetas
    y_blue = np.zeros(n_blue, dtype=int)
    y_red = np.ones(n_red, dtype=int)

    # Unir datos
    X_blue = np.vstack((x1_blue, x2_blue)).T
    X_red = np.vstack((x1_red, x2_red)).T
    X = np.vstack((X_blue, X_red))
    y = np.concatenate((y_blue, y_red))

    return X, y

# Generar datos
n_samples = 200
noise_level = 0.03
x_train_cl, y_train_cl = generate_refined_data(n_samples, noise_level=noise_level)

# Parámetros de entrenamiento
n_iter_train_cl = int(500)
loss_tol_cl = 0.01
seed = 42

# MLP
mlp_cl = FeedForward(
    [2, 3, 2],
    eps=0.02,
    activation=tanh_act,
    neuron_class=NeuronNN,
    loss=CrossEntropyLoss,
    seed=seed,
    weights_range=[-0.5, 0.5]
)

mlp_cl.train(x_train_cl, y_train_cl.reshape(-1, 1), n_iter_max=n_iter_train_cl, loss_tol=loss_tol_cl)

# KAN
kan_cl = FeedForward(
    [2, 2],  # Tamaño de las capas
    eps=0.01,  # Gradiente descendente
    n_weights_per_edge=8,  # Número de funciones de borde
    neuron_class=NeuronKAN,
    loss=CrossEntropyLoss,
    x_bounds=[-1, 1],  # Límites de entrada
    get_edge_fun=get_bsplines,
    seed=seed,
    weights_range=[-0.5, 0.5]
)

kan_cl.train(x_train_cl, y_train_cl.reshape(-1, 1), n_iter_max=n_iter_train_cl, loss_tol=loss_tol_cl)

# Crear malla para evaluar modelos
X1_cl, X2_cl = np.meshgrid(np.linspace(-1.5, 1.5, 100), np.linspace(-1.5, 1.5, 100))
x_cl = np.concatenate((X1_cl.reshape(-1, 1), X2_cl.reshape(-1, 1)), axis=1)

# Predicciones para visualización
def softmax(vec):
    exp_vec = np.exp(vec - np.max(vec))
    return exp_vec / np.sum(exp_vec)

Y_kan_cl = np.array([softmax(kan_cl(x))[1] for x in x_cl]).reshape(X1_cl.shape)
Y_mlp_cl = np.array([softmax(mlp_cl(x))[1] for x in x_cl]).reshape(X1_cl.shape)

# Graficar los resultados en una fila
fig, ax = plt.subplots(1, 4, figsize=(18, 4))

# Datos originales
ax[0].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr, edgecolor="k")
ax[0].axline((0, 0.5), slope=-1, color="black", linestyle="--", label="Separación real")
ax[0].set_title("Training Data")
ax[0].legend()
ax[0].set_xlabel("Feature 1")
ax[0].set_ylabel("Feature 2")
ax[0].grid()

# Clasificación KAN
im0 = ax[1].pcolor(X1_cl, X2_cl, Y_kan_cl, cmap=plt.cm.bwr, shading='auto', vmin=0, vmax=1)
ax[1].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr, edgecolor="k")
ax[1].set_title("KAN Classification")
fig.colorbar(im0, ax=ax[1])
ax[1].set_xlabel("Feature 1")
ax[1].set_ylabel("Feature 2")

# Clasificación MLP
im1 = ax[2].pcolor(X1_cl, X2_cl, Y_mlp_cl, cmap=plt.cm.bwr, shading='auto', vmin=0, vmax=1)
ax[2].scatter(*x_train_cl.T, c=y_train_cl, cmap=plt.cm.bwr, edgecolor="k")
ax[2].set_title("MLP Classification")
fig.colorbar(im1, ax=ax[2])
ax[2].set_xlabel("Feature 1")
ax[2].set_ylabel("Feature 2")

# Pérdida vs Iteraciones
ax[3].plot(kan_cl.loss_hist, label='KAN Loss', color='blue', linewidth=2)
ax[3].plot(mlp_cl.loss_hist, label='MLP Loss', color='orange', linewidth=2)
ax[3].axhline(y=loss_tol_cl, color='black', linestyle='--', label='Loss Tolerance')
ax[3].set_title("Loss vs Iterations")
ax[3].set_xlabel("Iterations")
ax[3].set_ylabel("Loss")
ax[3].legend()
ax[3].grid()

plt.tight_layout()
plt.show()

"""Aquí se puede observar un mejor comportamiento para MLP que para KAN en este problema que se diseñó para que la región de clasificación sea lineal y no compleja. En el gráfico de Loss v/s Iterations se puede observar una mayor precisión para MLP que para KAN, pero de igual manera pasado cierto rango de iteraciones, el modelo KAN logra entender la relación esperada para este modelo pero con menor velocidad que MLP.
Ambos modelos lograron capturar una región de clasificacón adecuada.

Al comparar los tres ejercicios presentes de clasificación se entiende que KAN tiene mejor comportamiento al clasificar datos con una relación de distribución compleja, a diferencia de MLP que tiene mayor precisión al clasificar datos que se distribuyen de manera lineal.

###**Discusión General**
En relación con el primer ejercicio, el modelo KAN sobresale por su capacidad para abordar problemas de clasificación con relaciones no lineales complejas. Este desempeño subraya su potencial en aplicaciones donde los datos presentan patrones difíciles de separar con modelos lineales o arquitecturas menos flexibles.

En el segundo ejercicio, al igual que en el primero, KAN se destaca como la opción más eficaz. Su habilidad para representar distribuciones no lineales altamente complejas, como las estructuras concéntricas, demuestra su superioridad frente al modelo MLP. Mientras que KAN consigue capturar estas geometrías de manera precisa, la MLP presenta limitaciones evidentes al enfrentarse a datos de este tipo, mostrando una menor capacidad de adaptación a patrones complejos.

##Item 3. Análisis y Explicación de la Arquitectura

La arquitectura **Kolmogorov-Arnold Networks** (*KAN*) se basa en el teorema de Kolmogorov-Arnold, que asegura que **cualquier función continua de múltiples variables puede descomponerse en una suma de funciones univariables compuestas**. Este principio permite construir redes neuronales capaces de aproximar cualquier función con alta precisión, aprovechando una combinación de transformaciones no lineales y estructuras diferenciables.

### Construcción de la Arquitectura
La implementación de la arquitectura KAN incluye los siguientes elementos principales:

1. ***Neuronas KAN (NeuronKAN):*** Estas neuronas amplían el concepto básico de una neurona tradicional al incorporar funciones llamadas **funciones de borde (edge functions)**. Las funciones de borde, como los *B-splines*, transforman las entradas de manera no lineal antes de ser ponderadas por los pesos y combinadas en la salida intermedia (xmid). Finalmente, la salida intermedia pasa por una función de activación, como tanh, para generar la salida final (xout).

2. ***Funciones de borde (B-splines):*** Son funciones diferenciables que segmentan el espacio de entrada en regiones, permitiendo una representación flexible de relaciones no lineales. Estas funciones se ajustan automáticamente durante el entrenamiento para optimizar la capacidad de modelado de las neuronas.

3. ***Capas completamente conectadas:*** Una capa consiste en un conjunto de NeuronKAN conectadas a través de pesos. Esta estructura permite transformar las entradas en representaciones más abstractas en las siguientes capas.

4. ***Cálculo de pérdida y retropropagación:*** La **pérdida** se calcula usando métricas como el error cuadrático medio (SquaredLoss) o entropía cruzada (CrossEntropyLoss). La **retropropagación** se encarga de actualizar los pesos a través del cálculo de gradientes, utilizando las derivadas exactas de las funciones de borde y de activación.

5. ***Proceso de entrenamiento:*** El modelo se entrena mediante el método de descenso de gradiente, optimizando los pesos de cada capa para minimizar la pérdida global en un conjunto de datos.

### Funcionamiento de KAN
El flujo de trabajo de una KAN incluye dos fases principales:

1. ***Transformación de entrada (Funciones de borde):*** Cada entrada pasa por una transformación no lineal usando funciones de borde, como los B-splines. Estas funciones segmentan el espacio de entrada y permiten una representación flexible de las relaciones entre las variables.

2. ***Ponderación y combinación:*** Las salidas de las funciones de borde son ponderadas por un conjunto de pesos asociados. Estas combinaciones ponderadas generan una salida intermedia (xmid) en cada neurona.

3. ***Función de activación:*** La salida intermedia es procesada por una función de activación (e.g., tanh), que introduce no linealidad en el modelo y permite manejar relaciones complejas entre las variables.

4. ***Cálculo de la salida final:*** La salida de cada capa pasa a la siguiente, continuando el procesamiento hasta obtener la salida final de la red. Este flujo permite transformar las entradas originales en representaciones cada vez más abstractas.

5. ***Retropropagación y aprendizaje:*** Durante el entrenamiento, el modelo calcula la diferencia entre las predicciones y las etiquetas reales (función de pérdida). Los gradientes se calculan y propagan hacia atrás, ajustando los pesos de cada neurona para minimizar la pérdida.

Las redes de Kolmogorov-Arnold (KAN) se han mostrado prometedoras en diversos campos debido a su capacidad para modelar relaciones complejas y no lineales con menos parámetros que las redes neuronales tradicionales. He aquí algunos casos de uso clave:
- **Modelización científica y ajuste de datos**
- **Resolución de ecuaciones diferenciales parciales (EDP)**
- **Regresión simbólica**

### Ventajas y Desventajas de las KAN
Las ventajas que posee esta arquitectura, mejoran las limitaciones de las redes convencionales:
- ***Interpretabilidad***: A diferencia de los modelos tradicionales de aprendizaje profundo, los KAN proporcionan una estructura más interpretable. Las funciones aprendibles pueden visualizarse y analizarse, ofreciendo información sobre el proceso de toma de decisiones del modelo. Esta característica es especialmente valiosa en los campos científicos, donde comprender el funcionamiento del modelo es tan crucial como lograr una gran precisión.
- ***Flexibilidad***: Las KAN no se limitan a un único tipo de función de activación. Aunque suelen utilizar B-splines, pueden emplearse otras funciones de base, como los polinomios de Chebyshev, en función de la tarea específica. Esta flexibilidad hace que la arquitectura sea versátil y adaptable a diversas aplicaciones.

Pero como cualquier tecnologia, vienen sus propias debilidades como:
- ***Complejidad computacional***: Uno de los retos de las KAN es su intensidad computacional durante la fase de entrenamiento. Como los KAN utilizan funciones de activación aprendibles en los bordes, la complejidad de la evaluación de estas funciones puede ralentizar considerablemente el proceso de entrenamiento en comparación con los MLP tradicionales. Esta complejidad se amplifica aún más en tareas que requieren arquitecturas KAN profundas o funciones base muy detalladas.
-***Necesidad de experiencia***: Implementar y ajustar las KAN puede ser más complejo que trabajar con MLP tradicionales. La selección de las funciones de base adecuadas (por ejemplo, B-splines, polinomios de Chebyshev) y la configuración del modelo para una tarea específica requieren una comprensión matemática más profunda y una mayor interacción entre el ser humano y el modelo. Esto puede hacer que las KAN sean menos accesibles para los profesionales sin conocimientos especializados.

### Analisis Detallados de los Resultados Obtenidos

#### Ejemplo 1: Regresión con Distribución Compleja y Lineal

KAN mostró una representación más precisa de los datos gracias a su capacidad de modelar relaciones no lineales utilizando funciones borde (b-spline).

Por otro lado, en las distribuciones lineales, MLP superó a KAN, mostrando una representación más precisa de la tendencia lineal de los datos.

Se destacan las ventajas de KAN en distribuciones complejas, KAN demostró mayor capacidad de representación debido a su flexibilidad y su habilidad para detectar comportamientos no lineales. Su convergencia más rápida para datos complejos reafirma su efectividad en escenarios donde la relación entre las variables no es trivial.

Mientras que sus limitaciones, demostro desventajas, principalmente debido a su tendencia a agregar patrones innecesarios que complicaron la representación de los datos.

#### Ejemplo 2: Regresión 2D

Para el ejemplo lineal KAN demostró un mejor comportamiento durante las primeras iteraciones. Esto se reflejó en la curva de pérdida, donde KAN mostró valores más bajos que MLP en el rango inicial. Sin embargo, a medida que avanzaron las iteraciones, MLP alcanzó la convergencia del valor de pérdida con mayor rapidez, logrando representar los datos lineales de forma precisa. Aunque KAN logró adaptarse adecuadamente a esta distribución, su mayor complejidad introdujo patrones innecesarios, resultando en un proceso de convergencia más lento.

Este ejemplo reafirma que KAN y MLP tienen puntos fuertes en diferentes contextos. KAN es más eficiente para datos con relaciones complejas y no lineales, mientras que MLP sobresale en escenarios donde los datos presentan distribuciones lineales claras. La elección entre ambos modelos debe estar guiada por la naturaleza de los datos a procesar y los objetivos del análisis.

#### Ejemplo 3: Clasificación con Datos Complejos

Una vez más los resultados confirman que **KAN supera a MLP en el escenario complejo**, logrando una mejor representación de los datos gracias a la flexibilidad de sus funciones spline. La gráfica de Loss v/s Iteraciones refuerza esta conclusión, mostrando que KAN alcanzó valores de pérdida más bajos que MLP a lo largo del entrenamiento.

MLP logró clasificar correctamente una de las clases para el ejemplo con datos distribuidos linealmente, pero presentó baja confianza en el problema complejo. Además, los bordes de decisión de MLP fueron rígidos y angulares, lo que refleja su **limitada capacidad para adaptarse a relaciones no lineales complejas**.

Se entiende con esto que ***KAN sobresale en problemas de clasificación con distribuciones complejas, mientras que MLP es más adecuado para clasificaciones lineales.*** Este comportamiento se alinea con lo observado en los ejercicios de regresión de los ejemplos anteriores. En particular, los resultados destacan cómo las propiedades de las funciones de activación (tangente hiperbólica en el tutorial y ReLU en el ejercicio de círculos concéntricos) influyen en la capacidad de los modelos para adaptarse a diferentes patrones.

En relación con los t*res ejercicios de clasificación*, se confirma que **KAN es la opción más eficaz para datos con relaciones complejas**, como estructuras concéntricas, **gracias a su capacidad de capturar patrones no lineales con mayor precisión**. Por otro lado, **MLP tiene un desempeño superior al enfrentar datos linealmente separables**, mostrando mayor rapidez y precisión en su convergencia.

En resumen, ***la elección del modelo debe basarse en la naturaleza de los datos y los requisitos del problema***, destacando la **flexibilidad de KAN y la eficiencia de MLP en sus respectivos dominios.**
"""